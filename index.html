<!DOCTYPE html>
<html>
<head>
    <title>2D/3D Wall Planner</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            overflow: hidden; /* Prevent scrollbars */
        }
        #menu {
            width: 250px;
            padding: 20px;
            background-color: #f0f0f0;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            height: 100vh;
            z-index: 10;
        }
        #menu h3 { margin-top: 0; }
        #menu .input-group { margin-bottom: 15px; }
        #menu label { display: block; margin-bottom: 5px; }
        #menu input, #menu button {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        #menu button {
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        #menu button:hover { background-color: #0056b3; }
        #menu .control-section button, #menu #metering-button.active { background-color: #dc3545; }
        #menu .control-section button:hover, #menu #metering-button.active:hover { background-color: #c82333; }
        #menu #load-button { background-color: #28a745; }
        #menu #load-button:hover { background-color: #218838; }
        #menu #info-button { background-color: #17a2b8; }
        #menu #info-button:hover { background-color: #138496; }

        #canvas-container {
            flex-grow: 1;
            position: relative;
        }
        #canvas-2d, #canvas-3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Info Modal */
        #info-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }
        .info-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
        }
        .info-content h2 { margin-top: 0; }
        .info-content ul { list-style-type: none; padding-left: 0;}
        .info-content li { margin-bottom: 10px; }
        .info-content kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-family: monospace;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="menu">
    <h3>File</h3>
    <button id="save-button">Save to File</button>
    <button id="load-button" onclick="document.getElementById('file-input').click()">Load from File</button>
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <hr>
    <h3>Insert</h3>
    <div class="input-group">
        <label for="wall-length">Wall Length (mm):</label>
        <input type="number" id="wall-length" value="4000">
    </div>
    <button id="insert-wall">Insert Wall</button>
    <button id="insert-item">Insert Item (Cube)</button>
    <hr>
    <h3>Controls</h3>
    <button id="metering-button">Start Metering</button>
    <button id="toggle-lengths">Show/Hide Lengths</button>
    <button id="info-button">Show Controls Info</button>

    <div id="selected-object-controls" class="control-section" style="display: none;">
        <hr><h3>Selected Object</h3>
        <button id="remove-object">Remove Selected</button>
        <!-- Wall-specific controls -->
        <div id="wall-editor-controls" style="display: none;">
            <div class="input-group">
                <label for="edit-wall-length">Length (mm):</label>
                <input type="number" id="edit-wall-length">
            </div>
            <div class="input-group">
                <label for="edit-wall-angle">Angle (°):</label>
                <input type="number" id="edit-wall-angle">
            </div>
        </div>
        <!-- Item-specific controls -->
        <div id="item-editor-controls" style="display: none;">
            <div class="input-group"><label for="item-width">Width (mm):</label><input type="number" id="item-width"></div>
            <div class="input-group"><label for="item-depth">Depth (mm):</label><input type="number" id="item-depth"></div>
            <div class="input-group"><label for="item-height">Height (mm):</label><input type="number" id="item-height"></div>
            <div class="input-group"><label for="item-y-position">Vertical Position (mm):</label><input type="number" id="item-y-position"></div>
        </div>
    </div>
    
    <hr>
    <h3>3D View</h3>
    <button id="toggle-3d">Switch to 3D</button>
    <div id="view-controls">
        <div class="input-group">
            <label for="wall-color">Selected Wall 3D Color:</label>
            <input type="color" id="wall-color" value="#ffffff">
        </div>
        <div class="input-group">
            <label for="floor-color">Floor Color:</label>
            <input type="color" id="floor-color" value="#808080">
        </div>
        <div class="input-group">
            <label for="wall-height">Default Wall Height (mm):</label>
            <input type="number" id="wall-height" value="2400">
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas-2d"></canvas>
    <div id="canvas-3d" style="display: none;"></div>
</div>

<div id="info-modal">
    <div class="info-content">
        <span class="close-button">&times;</span>
        <h2>Controls Guide</h2>
        <h3>2D Mode</h3>
        <ul>
            <li><b>Pan View:</b> <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> keys.</li>
            <li><b>Zoom:</b> Mouse Wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Select/Move/Rotate:</b> Click and drag objects. Use rotation handles.</li>
            <li><b>Multi-Select:</b> Hold <kbd>Shift</kbd> and click multiple objects.</li>
            <li><b>Metering:</b> Activate metering mode, then click on the canvas to draw a measuring line. Click near the start point to close the loop and calculate area.</li>
        </ul>
        <h3>3D Mode</h3>
        <ul>
            <li><b>Rotate View:</b> Click and drag with the left mouse button.</li>
            <li><b>Pan View:</b> Click and drag with the right mouse button.</li>
            <li><b>Zoom:</b> Use the mouse wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Move Camera (Walk):</b> <kbd>W</kbd> (forward), <kbd>A</kbd> (left), <kbd>S</kbd> (back), <kbd>D</kbd> (right).</li>
            <li><b>Move Camera (Strafe):</b> <kbd>I</kbd> (forward), <kbd>K</kbd> (back), <kbd>J</kbd> (left), <kbd>L</kbd> (right).</li>
            <li><b>Move Camera (Vertical):</b> <kbd>&uarr;</kbd> (up), <kbd>&darr;</kbd> (down).</li>
        </ul>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const canvasContainer = document.getElementById('canvas-container');
    const scale = 0.1;
    let showLengths = true;
    const keyState = {};
    let uidCounter = 0;

    // --- 2D Canvas ---
    const canvas2d = new fabric.Canvas('canvas-2d', {
        width: canvasContainer.clientWidth,
        height: canvasContainer.clientHeight,
        backgroundColor: 'white',
        preserveObjectStacking: true,
        renderOnAddRemove: false
    });
    const customProps = ['isWall', 'isItem', 'itemProps', 'uid', 'color3d'];
    let lengthTextObjects = {};

    // --- Metering State ---
    let isMeteringMode = false;
    let meteringPoints = [];
    let meteringObjects = [];
    
    // --- 3D Scene ---
    let scene, camera, renderer, controls;
    let floor;
    let sceneObjects3D = {};
    const canvas3d = document.getElementById('canvas-3d');
    let is3DMode = false;
    
    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
        const activeEl = document.activeElement;
        if(activeEl.tagName !== 'INPUT') {
            keyState[e.key.toLowerCase()] = true;
            handleGlobalKeys(e);
        }
    });
    document.addEventListener('keyup', (e) => keyState[e.key.toLowerCase()] = false);
    
    document.getElementById('save-button').addEventListener('click', saveToFile);
    document.getElementById('file-input').addEventListener('change', loadFromFile);
    document.getElementById('info-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'block');
    document.querySelector('.close-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'none');
    window.addEventListener('click', (e) => { if (e.target == document.getElementById('info-modal')) e.target.style.display = 'none'; });
    
    document.getElementById('insert-wall').addEventListener('click', insertWall);
    document.getElementById('insert-item').addEventListener('click', insertItem);
    document.getElementById('remove-object').addEventListener('click', removeSelectedObject);
    document.getElementById('toggle-lengths').addEventListener('click', toggleLengthVisibility);
    document.getElementById('toggle-3d').addEventListener('click', toggle3DMode);
    document.getElementById('metering-button').addEventListener('click', toggleMeteringMode);

    document.getElementById('edit-wall-length').addEventListener('input', updateWallFromMenu);
    document.getElementById('edit-wall-angle').addEventListener('input', updateWallFromMenu);
    document.getElementById('wall-color').addEventListener('input', update3DColorFromMenu);
    
    ['item-width', 'item-depth', 'item-height', 'item-y-position'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateItemFromMenu);
    });

    window.addEventListener('resize', onWindowResize);
    
    // --- Canvas Event Listeners ---
    function updateTextForObject(obj) {
        if (!showLengths || !obj) return;
        if (obj.isWall) updateLengthTextFor(obj);
    }

    canvas2d.on({
        'mouse:wheel': handle2DZoom,
        'mouse:down': handleMouseDown,
        'selection:created': updateMenu,
        'selection:updated': updateMenu,
        'selection:cleared': updateMenu,
        'object:modified': (e) => updateMenu(e),
        'object:moving': (e) => updateTextForObject(e.target),
        'object:rotating': (e) => updateTextForObject(e.target),
        'object:scaling': (e) => updateTextForObject(e.target)
    });

    // --- Core Functions ---

    function removeSelectedObject() {
        canvas2d.getActiveObjects().forEach(activeObject => {
            if (lengthTextObjects[activeObject.uid]) {
                canvas2d.remove(lengthTextObjects[activeObject.uid]);
                delete lengthTextObjects[activeObject.uid];
            }
            if (sceneObjects3D[activeObject.uid]) {
                scene.remove(sceneObjects3D[activeObject.uid]);
                delete sceneObjects3D[activeObject.uid];
            }
            canvas2d.remove(activeObject);
        });
        canvas2d.discardActiveObject();
        canvas2d.requestRenderAll();
    }

    function saveToFile() {
        const originalObjects = canvas2d.getObjects().filter(o => !o.isLengthText && !o.isMeteringObject);
        const json = canvas2d.toObject(customProps);
        json.objects = originalObjects.map(o => o.toObject(customProps));
        const dataStr = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(json, null, 2))}`;
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "plan.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    function loadFromFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            canvas2d.loadFromJSON(f.target.result, () => {
                canvas2d.getObjects().forEach(obj => {
                    if (obj.uid === undefined) obj.uid = ++uidCounter;
                });
                updateAllLengthTexts();
                canvas2d.requestRenderAll();
            });
        };
        reader.readAsText(file);
        e.target.value = '';
    }
    
    function handleGlobalKeys(e) {
        const key = e.key.toLowerCase();
        if (key === 'r' || key === 'f') {
            e.preventDefault();
            const zoomFactor = 1.1;
            const zoom = key === 'r' ? zoomFactor : 1 / zoomFactor;
            if (is3DMode) {
                 const forward = new THREE.Vector3();
                 camera.getWorldDirection(forward);
                 camera.position.addScaledVector(forward, (1 - 1/zoom) * 1000);
            } else {
                canvas2d.zoomToPoint(new fabric.Point(canvas2d.width / 2, canvas2d.height / 2), canvas2d.getZoom() * zoom);
            }
        }
    }

    function handle2DZoom(opt) {
        if (isMeteringMode) return;
        opt.e.preventDefault();
        opt.e.stopPropagation();
        const delta = opt.e.deltaY;
        let zoom = canvas2d.getZoom();
        zoom *= 0.999 ** delta;
        if (zoom > 20) zoom = 20;
        if (zoom < 0.1) zoom = 0.1;
        canvas2d.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
    }

    function handle2DPan() {
        if(is3DMode) return;
        const panSpeed = 15 / canvas2d.getZoom();
        let panX = 0, panY = 0;
        if (keyState['w']) panY += panSpeed;
        if (keyState['s']) panY -= panSpeed;
        if (keyState['a']) panX += panSpeed;
        if (keyState['d']) panX -= panSpeed;

        if (panX !== 0 || panY !== 0) {
            canvas2d.relativePan(new fabric.Point(panX, panY));
        }
    }
    
    function handle3DCameraMovement() {
        if(!is3DMode) return;
        const moveSpeed = 15.0;
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
        const moveDirection = new THREE.Vector3(0,0,0);

        if (keyState['w'] || keyState['i']) moveDirection.add(forward);
        if (keyState['s'] || keyState['k']) moveDirection.sub(forward);
        if (keyState['a'] || keyState['j']) moveDirection.sub(right);
        if (keyState['d'] || keyState['l']) moveDirection.add(right);
        
        if(moveDirection.lengthSq() > 0){
            const finalMove = moveDirection.normalize().multiplyScalar(moveSpeed);
            camera.position.add(finalMove);
            controls.target.add(finalMove);
        }

        if (keyState['arrowup']) camera.position.y += moveSpeed;
        if (keyState['arrowdown']) camera.position.y -= moveSpeed;
    }

    function insertWall() {
        const length = document.getElementById('wall-length').value;
        const wall = new fabric.Rect({
            width: length * scale, height: 10, fill: 'black', left: 50, top: 50,
            originX: 'left', originY: 'top', isWall: true, uid: ++uidCounter
        });
        canvas2d.add(wall);

        if (showLengths) {
            updateLengthTextFor(wall);
        }
        
        canvas2d.requestRenderAll();
    }

    function insertItem() {
        const item = new fabric.Rect({
            width: 600 * scale, height: 600 * scale, fill: '#A52A2A', left: 200, top: 200,
            isItem: true, 
            itemProps: { width: 600, depth: 600, height: 800, y: 0, color: '#A52A2A' }, 
            uid: ++uidCounter
        });
        canvas2d.add(item).requestRenderAll();
    }

    function updateMenu(e) {
        if (isMeteringMode) return;
        document.getElementById('selected-object-controls').style.display = 'none';
        document.getElementById('wall-editor-controls').style.display = 'none';
        document.getElementById('item-editor-controls').style.display = 'none';
        
        const activeObjects = canvas2d.getActiveObjects();
        if (activeObjects.length === 0) return;

        document.getElementById('selected-object-controls').style.display = 'block';

        if (activeObjects.length === 1) {
            const obj = activeObjects[0];
            if (obj.isWall) {
                document.getElementById('wall-editor-controls').style.display = 'block';
                document.getElementById('edit-wall-length').value = Math.round(obj.getScaledWidth() / scale);
                document.getElementById('edit-wall-angle').value = Math.round(obj.angle);
            } else if (obj.isItem) {
                document.getElementById('item-editor-controls').style.display = 'block';
                
                const currentWidthMM = obj.getScaledWidth() / scale;
                const currentDepthMM = obj.getScaledHeight() / scale;
                obj.itemProps.width = currentWidthMM;
                obj.itemProps.depth = currentDepthMM;
                
                document.getElementById('item-width').value = Math.round(currentWidthMM);
                document.getElementById('item-depth').value = Math.round(currentDepthMM);
                document.getElementById('item-height').value = obj.itemProps.height;
                document.getElementById('item-y-position').value = obj.itemProps.y || 0;
            }
        }
    }
    
    function updateWallFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isWall) return;

        const newLength = document.getElementById('edit-wall-length').value;
        const newAngle = document.getElementById('edit-wall-angle').value;

        activeObject.set({
            width: newLength * scale,
            angle: parseFloat(newAngle)
        });
        activeObject.scaleX = 1;
        activeObject.setCoords();
        canvas2d.requestRenderAll();
        updateTextForObject(activeObject);
    }
    
    function update3DColorFromMenu() {
        const color = document.getElementById('wall-color').value;
        canvas2d.getActiveObjects().forEach(obj => {
            if (obj.isWall) obj.color3d = color;
        });
        if (is3DMode) update3DScene();
    }

    function updateItemFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isItem) return;
        
        const props = activeObject.itemProps;
        props.width = document.getElementById('item-width').value;
        props.depth = document.getElementById('item-depth').value;
        props.height = document.getElementById('item-height').value;
        props.y = parseFloat(document.getElementById('item-y-position').value) || 0;

        activeObject.set({
            width: props.width * scale,
            height: props.depth * scale,
            scaleX: 1,
            scaleY: 1
        }).setCoords();
        
        canvas2d.requestRenderAll();
        
        if (is3DMode) {
            const mesh3d = sceneObjects3D[activeObject.uid];
            if (mesh3d) {
                mesh3d.geometry.dispose();
                mesh3d.geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
                mesh3d.position.y = (props.height * scale) / 2 + (props.y * scale);
            }
        }
    }
    
    function toggleLengthVisibility() {
        showLengths = !showLengths;
        Object.values(lengthTextObjects).forEach(text => text.visible = showLengths);
        if (showLengths) updateAllLengthTexts();
        canvas2d.requestRenderAll();
    }

    function updateAllLengthTexts() {
        const visibleObjects = new Set();
        canvas2d.getObjects().forEach(obj => {
            if (obj.isWall) {
                updateLengthTextFor(obj);
                visibleObjects.add(obj.uid);
            }
        });
        for (const uid in lengthTextObjects) {
            if (!visibleObjects.has(parseInt(uid))) lengthTextObjects[uid].visible = false;
        }
    }

    function updateLengthTextFor(wall) {
        let textObj = lengthTextObjects[wall.uid];
        if (!textObj) {
            textObj = new fabric.Text('', { fontSize: 12, fill: 'black', originX: 'center', originY: 'center', selectable: false, evented: false });
            lengthTextObjects[wall.uid] = textObj;
            canvas2d.add(textObj);
        }

        textObj.visible = true;
        textObj.text = `${Math.round(wall.getScaledWidth() / scale)} mm`;
        const d = fabric.util.qrDecompose(wall.calcTransformMatrix());
        const center = new fabric.Point(d.translateX, d.translateY);
        const offset = new fabric.Point(0, -20);
        const rotatedOffset = fabric.util.rotatePoint(offset, new fabric.Point(0,0), fabric.util.degreesToRadians(d.angle));
        
        textObj.set({
            left: center.x + rotatedOffset.x,
            top: center.y + rotatedOffset.y,
            angle: d.angle
        });
        textObj.bringToFront();
    }

    function onWindowResize() {
        const w = canvasContainer.clientWidth, h = canvasContainer.clientHeight;
        canvas2d.setDimensions({ width: w, height: h });
        if (is3DMode) {
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }
    }

    function toggle3DMode() {
        is3DMode = !is3DMode;
        if (is3DMode) {
            document.getElementById('toggle-3d').textContent = 'Switch to 2D';
            canvas2d.getElement().style.display = 'none';
            canvas3d.style.display = 'block';
            if (!renderer) init3D();
            onWindowResize();
            update3DScene();
        } else {
            document.getElementById('toggle-3d').textContent = 'Switch to 3D';
            canvas2d.getElement().style.display = 'block';
            canvas3d.style.display = 'none';
        }
    }

    // --- Metering Functions ---
    
    function toggleMeteringMode() {
        const btn = document.getElementById('metering-button');
        isMeteringMode = !isMeteringMode;
        if (isMeteringMode) {
            btn.textContent = 'Cancel Metering';
            btn.classList.add('active');
            clearMetering(); // Clear any previous measurement
            canvas2d.selection = false;
            canvas2d.forEachObject(o => o.set('evented', false));
        } else {
            btn.textContent = 'Start Metering';
            btn.classList.remove('active');
            clearMetering();
            canvas2d.selection = true;
            canvas2d.forEachObject(o => o.set('evented', true));
        }
    }

    function clearMetering() {
        canvas2d.remove(...meteringObjects);
        meteringObjects = [];
        meteringPoints = [];
        canvas2d.requestRenderAll();
    }

    function handleMouseDown(opt) {
        if (!isMeteringMode) return;
        const pointer = canvas2d.getPointer(opt.e);

        // Check for loop close
        if (meteringPoints.length > 2) {
            const startPoint = meteringPoints[0];
            const dist = Math.sqrt(Math.pow(startPoint.x - pointer.x, 2) + Math.pow(startPoint.y - pointer.y, 2));
            if (dist < 10) { // Close loop if click is near start point
                drawMeteringLine(meteringPoints[meteringPoints.length - 1], startPoint);
                calculateAndShowArea();
                // End metering session, requires user to click cancel/start to do another
                isMeteringMode = false; 
                return;
            }
        }

        meteringPoints.push(pointer);
        const circle = new fabric.Circle({
            radius: 3, fill: 'red', left: pointer.x, top: pointer.y,
            originX: 'center', originY: 'center', isMeteringObject: true
        });
        meteringObjects.push(circle);
        canvas2d.add(circle);

        if (meteringPoints.length > 1) {
            const prevPoint = meteringPoints[meteringPoints.length - 2];
            drawMeteringLine(prevPoint, pointer);
        }
    }

    function drawMeteringLine(p1, p2) {
        const line = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
            stroke: 'red', strokeWidth: 2, selectable: false, evented: false, isMeteringObject: true
        });
        meteringObjects.push(line);
        canvas2d.add(line);
        
        // Add length text
        const lengthPx = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        const lengthMM = lengthPx / scale;
        const text = new fabric.Text(`${Math.round(lengthMM)} mm`, {
            left: (p1.x + p2.x) / 2,
            top: (p1.y + p2.y) / 2,
            fontSize: 14,
            fill: 'black',
            originX: 'center',
            originY: 'center',
            isMeteringObject: true
        });
        meteringObjects.push(text);
        canvas2d.add(text);
    }
    
    function calculateAndShowArea() {
        // Shoelace formula for area in pixels
        let areaPx = 0;
        for (let i = 0; i < meteringPoints.length; i++) {
            const p1 = meteringPoints[i];
            const p2 = meteringPoints[(i + 1) % meteringPoints.length];
            areaPx += (p1.x * p2.y - p2.x * p1.y);
        }
        areaPx = Math.abs(areaPx) / 2;

        // Convert px² to m²
        const mPerPx = 1 / scale / 1000;
        const areaM2 = areaPx * mPerPx * mPerPx;
        
        // Find centroid to place text
        let centroid = { x: 0, y: 0 };
        meteringPoints.forEach(p => {
            centroid.x += p.x;
            centroid.y += p.y;
        });
        centroid.x /= meteringPoints.length;
        centroid.y /= meteringPoints.length;

        const areaText = new fabric.Text(`${areaM2.toFixed(2)} m²`, {
            left: centroid.x,
            top: centroid.y,
            fontSize: 16,
            fill: 'blue',
            fontWeight: 'bold',
            originX: 'center',
            originY: 'center',
            isMeteringObject: true
        });
        meteringObjects.push(areaText);
        canvas2d.add(areaText);
    }

    // --- 3D Scene Management ---
    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 1, 20000);
        camera.position.set(500, 800, 1300);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        canvas3d.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(150, 200, 100);
        scene.add(dirLight);
        const floorGeometry = new THREE.PlaneGeometry(10000, 10000);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: document.getElementById('floor-color').value });
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;
        camera.lookAt(controls.target);
    }
    
    function update3DScene() {
        Object.values(sceneObjects3D).forEach(obj => scene.remove(obj));
        sceneObjects3D = {};
        const wallHeight = document.getElementById('wall-height').value * scale;
        const defaultWallColor = '#ffffff'; 
        if(floor) floor.material.color.set(document.getElementById('floor-color').value);

        canvas2d.getObjects().forEach(obj2d => {
            if(obj2d.isLengthText || obj2d.isMeteringObject) return;
            if (obj2d.isItem) create3DItem(obj2d);
            else if (obj2d.isWall) create3DWall(obj2d, wallHeight, defaultWallColor);
        });
    }

    function create3DWall(wall2d, wallHeight, defaultColor) {
        const d = fabric.util.qrDecompose(wall2d.calcTransformMatrix());
        const geometry = new THREE.BoxGeometry(wall2d.getScaledWidth(), wallHeight, wall2d.getScaledHeight());
        const color = wall2d.color3d || defaultColor;
        const material = new THREE.MeshStandardMaterial({ color: color });
        const wall3d = new THREE.Mesh(geometry, material);
        
        wall3d.position.set(d.translateX - canvas2d.width / 2, wallHeight / 2, d.translateY - canvas2d.height / 2);
        wall3d.rotation.y = -fabric.util.degreesToRadians(d.angle);
        sceneObjects3D[wall2d.uid] = wall3d;
        scene.add(wall3d);
    }
    
    function create3DItem(item2d) {
        const props = item2d.itemProps;
        const color = props.color;
        const geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
        const material = new THREE.MeshStandardMaterial({ color: color });
        const item3d = new THREE.Mesh(geometry, material);
        const center = item2d.getCenterPoint();
        item3d.position.set(
            center.x - canvas2d.width/2, 
            (props.height * scale)/2 + ((props.y || 0) * scale), 
            center.y - canvas2d.height/2
        );
        item3d.rotation.y = -fabric.util.degreesToRadians(item2d.angle);
        sceneObjects3D[item2d.uid] = item3d;
        scene.add(item3d);
    }

    // --- Main Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        if (is3DMode) {
            handle3DCameraMovement();
            controls.update();
            renderer.render(scene, camera);
        } else {
            handle2DPan();
            canvas2d.renderAll();
        }
    }

    // Initial setup
    updateAllLengthTexts();
    canvas2d.requestRenderAll();
    animate();
</script>

</body>
</html>
