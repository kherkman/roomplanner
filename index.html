<!DOCTYPE html>
<html>
<head>
    <title>2D/3D Wall Planner</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            overflow: hidden; /* Prevent scrollbars */
        }
        #menu {
            width: 250px;
            padding: 20px;
            background-color: #f0f0f0;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            height: 100vh;
            z-index: 10;
        }
        #menu h3 { margin-top: 0; }
        #menu .input-group { margin-bottom: 15px; }
        #menu label { display: block; margin-bottom: 5px; }
        #menu input, #menu button {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        #menu button {
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        #menu button:hover { background-color: #0056b3; }
        #menu .control-section button, #menu #metering-button.active { background-color: #dc3545; }
        #menu .control-section button:hover, #menu #metering-button.active:hover { background-color: #c82333; }
        #menu #load-button { background-color: #28a745; }
        #menu #load-button:hover { background-color: #218838; }
        #menu #info-button { background-color: #17a2b8; }
        #menu #info-button:hover { background-color: #138496; }

        #canvas-container {
            flex-grow: 1;
            position: relative;
        }
        #canvas-2d, #canvas-3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Info Modal */
        #info-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }
        .info-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
        }
        .info-content h2 { margin-top: 0; }
        .info-content ul { list-style-type: none; padding-left: 0;}
        .info-content li { margin-bottom: 10px; }
        .info-content kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-family: monospace;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="menu">
    <h3>File</h3>
    <button id="save-button">Save to File</button>
    <button id="load-button" onclick="document.getElementById('file-input').click()">Load from File</button>
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <hr>
    <h3>Insert</h3>
    <div class="input-group">
        <label for="wall-length">Wall Length (mm):</label>
        <input type="number" id="wall-length" value="4000">
    </div>
    <button id="insert-wall">Insert Wall</button>
    <button id="insert-item">Insert Item (Cube)</button>
    <button id="insert-door">Insert a Door</button>
    <button id="insert-window">Insert a Window</button>
    <hr>
    <h3>Controls</h3>
    <button id="metering-button">Start Metering</button>
    <button id="toggle-lengths">Show/Hide Lengths</button>
    <button id="info-button">Show Controls Info</button>

    <div id="selected-object-controls" class="control-section" style="display: none;">
        <hr><h3>Selected Object</h3>
        <button id="remove-object">Remove Selected</button>
        <!-- Wall -->
        <div id="wall-editor-controls">
            <div class="input-group"><label for="edit-wall-length">Length (mm):</label><input type="number" id="edit-wall-length"></div>
            <div class="input-group"><label for="edit-wall-angle">Angle (°):</label><input type="number" id="edit-wall-angle"></div>
        </div>
        <!-- Item -->
        <div id="item-editor-controls">
            <div class="input-group"><label for="item-width">Width (mm):</label><input type="number" id="item-width"></div>
            <div class="input-group"><label for="item-depth">Depth (mm):</label><input type="number" id="item-depth"></div>
            <div class="input-group"><label for="item-height">Height (mm):</label><input type="number" id="item-height"></div>
            <div class="input-group"><label for="item-y-position">Vertical Position (mm):</label><input type="number" id="item-y-position"></div>
        </div>
        <!-- Door -->
        <div id="door-editor-controls">
            <div class="input-group"><label for="door-width">Width (mm):</label><input type="number" id="door-width"></div>
            <div class="input-group"><label for="door-height">Height (mm):</label><input type="number" id="door-height"></div>
            <button id="toggle-door">Open/Close Door</button>
        </div>
        <!-- Window -->
        <div id="window-editor-controls">
             <div class="input-group"><label for="window-width">Width (mm):</label><input type="number" id="window-width"></div>
            <div class="input-group"><label for="window-height">Height (mm):</label><input type="number" id="window-height"></div>
            <div class="input-group"><label for="window-y-position">Vertical Position (mm):</label><input type="number" id="window-y-position"></div>
        </div>
    </div>
    
    <hr>
    <h3>3D View</h3>
    <button id="toggle-3d">Switch to 3D</button>
    <div id="view-controls">
        <div class="input-group"><label for="wall-color">Selected Wall 3D Color:</label><input type="color" id="wall-color" value="#ffffff"></div>
        <div class="input-group"><label for="floor-color">Floor Color:</label><input type="color" id="floor-color" value="#808080"></div>
        <div class="input-group"><label for="wall-height">Default Wall Height (mm):</label><input type="number" id="wall-height" value="2400"></div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas-2d"></canvas>
    <div id="canvas-3d" style="display: none;"></div>
</div>

<div id="info-modal">
    <div class="info-content">
        <span class="close-button">&times;</span>
        <h2>Controls Guide</h2>
        <h3>2D Mode</h3>
        <ul>
            <li><b>Pan View:</b> <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> keys.</li>
            <li><b>Zoom:</b> Mouse Wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Select/Move/Rotate:</b> Click and drag objects. Use rotation handles.</li>
            <li><b>Snapping:</b> Drag a Door or Window over a Wall to snap it in place.</li>
            <li><b>Multi-Select:</b> Hold <kbd>Shift</kbd> and click multiple objects.</li>
            <li><b>Metering:</b> Activate metering mode, then click on the canvas to draw a measuring line. Click near the start point to close the loop and calculate area.</li>
        </ul>
        <h3>3D Mode</h3>
        <ul>
            <li><b>Rotate View:</b> Click and drag with the left mouse button.</li>
            <li><b>Pan View:</b> Click and drag with the right mouse button.</li>
            <li><b>Zoom:</b> Use the mouse wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Move Camera (Walk):</b> <kbd>W</kbd> (forward), <kbd>A</kbd> (left), <kbd>S</kbd> (back), <kbd>D</kbd> (right).</li>
            <li><b>Move Camera (Strafe):</b> <kbd>I</kbd> (forward), <kbd>K</kbd> (back), <kbd>J</kbd> (left), <kbd>L</kbd> (right).</li>
            <li><b>Move Camera (Vertical):</b> <kbd>&uarr;</kbd> (up), <kbd>&darr;</kbd> (down).</li>
        </ul>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three-csg-ts@3.1.11/dist/index.min.js"></script>

<script>
    const canvasContainer = document.getElementById('canvas-container');
    const scale = 0.1;
    let showLengths = true;
    const keyState = {};
    let uidCounter = 0;

    // --- 2D Canvas ---
    const canvas2d = new fabric.Canvas('canvas-2d', {
        width: canvasContainer.clientWidth,
        height: canvasContainer.clientHeight,
        backgroundColor: 'white',
        preserveObjectStacking: true,
        renderOnAddRemove: false
    });
    const customProps = ['isWall', 'isItem', 'isDoor', 'isWindow', 'itemProps', 'doorProps', 'windowProps', 'uid', 'color3d', 'parentWallUid'];
    let lengthTextObjects = {};

    // --- Metering State ---
    let isMeteringMode = false;
    let meteringPoints = [];
    let meteringObjects = [];
    
    // --- 3D Scene ---
    let scene, camera, renderer, controls;
    let floor;
    let sceneObjects3D = {};
    const canvas3d = document.getElementById('canvas-3d');
    let is3DMode = false;
    
    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
        const activeEl = document.activeElement;
        if(activeEl.tagName !== 'INPUT') {
            keyState[e.key.toLowerCase()] = true;
            handleGlobalKeys(e);
        }
    });
    document.addEventListener('keyup', (e) => keyState[e.key.toLowerCase()] = false);
    
    document.getElementById('save-button').addEventListener('click', saveToFile);
    document.getElementById('file-input').addEventListener('change', loadFromFile);
    document.getElementById('info-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'block');
    document.querySelector('.close-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'none');
    window.addEventListener('click', (e) => { if (e.target == document.getElementById('info-modal')) e.target.style.display = 'none'; });
    
    document.getElementById('insert-wall').addEventListener('click', insertWall);
    document.getElementById('insert-item').addEventListener('click', insertItem);
    document.getElementById('insert-door').addEventListener('click', insertDoor);
    document.getElementById('insert-window').addEventListener('click', insertWindow);
    document.getElementById('remove-object').addEventListener('click', removeSelectedObject);
    document.getElementById('toggle-lengths').addEventListener('click', toggleLengthVisibility);
    document.getElementById('toggle-3d').addEventListener('click', toggle3DMode);
    document.getElementById('metering-button').addEventListener('click', toggleMeteringMode);
    document.getElementById('toggle-door').addEventListener('click', toggleDoorState);
    
    document.getElementById('edit-wall-length').addEventListener('input', updateWallFromMenu);
    document.getElementById('edit-wall-angle').addEventListener('input', updateWallFromMenu);
    document.getElementById('wall-color').addEventListener('input', update3DColorFromMenu);
    ['item-width', 'item-depth', 'item-height', 'item-y-position'].forEach(id => document.getElementById(id).addEventListener('input', updateItemFromMenu));
    ['door-width', 'door-height'].forEach(id => document.getElementById(id).addEventListener('input', updateDoorFromMenu));
    ['window-width', 'window-height', 'window-y-position'].forEach(id => document.getElementById(id).addEventListener('input', updateWindowFromMenu));

    window.addEventListener('resize', onWindowResize);
    
    // --- Canvas Event Listeners ---
    function updateTextForObject(obj) {
        if (!showLengths || !obj) return;
        if (obj.isWall) updateLengthTextFor(obj);
    }
    
    function handleObjectMoving(e) {
        const obj = e.target;
        if (obj.isDoor || obj.isWindow) handleSnapping(obj);
        if (obj.isWall) updateTextForObject(obj);
        if (obj.isDoor) obj.doorArc?.setCoords();
    }

    canvas2d.on({
        'mouse:wheel': handle2DZoom,
        'mouse:down': handleMouseDown,
        'selection:created': updateMenu,
        'selection:updated': updateMenu,
        'selection:cleared': updateMenu,
        'object:modified': (e) => updateMenu(e),
        'object:moving': handleObjectMoving,
        'object:rotating': (e) => {
            updateTextForObject(e.target);
            if (e.target.isDoor) e.target.doorArc?.setCoords();
        },
        'object:scaling': (e) => updateTextForObject(e.target)
    });

    // --- Core Functions ---
    function removeSelectedObject() {
        canvas2d.getActiveObjects().forEach(activeObject => {
            if (lengthTextObjects[activeObject.uid]) {
                canvas2d.remove(lengthTextObjects[activeObject.uid]);
                delete lengthTextObjects[activeObject.uid];
            }
            if (sceneObjects3D[activeObject.uid]) {
                const obj3d = sceneObjects3D[activeObject.uid];
                obj3d.geometry?.dispose();
                obj3d.material?.dispose();
                scene.remove(obj3d);
                delete sceneObjects3D[activeObject.uid];
            }
            if (activeObject.doorArc) canvas2d.remove(activeObject.doorArc);
            canvas2d.remove(activeObject);
        });
        canvas2d.discardActiveObject();
        canvas2d.requestRenderAll();
    }

    function saveToFile() {
        const originalObjects = canvas2d.getObjects().filter(o => !o.isLengthText && !o.isMeteringObject && !o.isDoorArc);
        const json = canvas2d.toObject(customProps);
        json.objects = originalObjects.map(o => o.toObject(customProps));
        const dataStr = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(json, null, 2))}`;
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "plan.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    function loadFromFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            canvas2d.loadFromJSON(f.target.result, () => {
                canvas2d.getObjects().forEach(obj => {
                    if (obj.uid === undefined) obj.uid = ++uidCounter;
                    if (obj.isDoor) createDoorArc(obj);
                });
                updateAllLengthTexts();
                canvas2d.requestRenderAll();
            });
        };
        reader.readAsText(file);
        e.target.value = '';
    }
    
    // --- Camera & View Controls ---
    function handleGlobalKeys(e) {
        const key = e.key.toLowerCase();
        if (key === 'r' || key === 'f') {
            e.preventDefault();
            const zoomFactor = 1.1;
            const zoom = key === 'r' ? zoomFactor : 1 / zoomFactor;
            if (is3DMode) {
                 const forward = new THREE.Vector3();
                 camera.getWorldDirection(forward);
                 camera.position.addScaledVector(forward, (1 - 1/zoom) * 1000);
            } else {
                canvas2d.zoomToPoint(new fabric.Point(canvas2d.width / 2, canvas2d.height / 2), canvas2d.getZoom() * zoom);
            }
        }
    }

    function handle2DZoom(opt) {
        if (isMeteringMode) return;
        opt.e.preventDefault();
        opt.e.stopPropagation();
        const delta = opt.e.deltaY;
        let zoom = canvas2d.getZoom();
        zoom *= 0.999 ** delta;
        if (zoom > 20) zoom = 20;
        if (zoom < 0.1) zoom = 0.1;
        canvas2d.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
    }

    function handle2DPan() {
        if(is3DMode) return;
        const panSpeed = 15 / canvas2d.getZoom();
        let panX = 0, panY = 0;
        if (keyState['w']) panY += panSpeed;
        if (keyState['s']) panY -= panSpeed;
        if (keyState['a']) panX += panSpeed;
        if (keyState['d']) panX -= panSpeed;

        if (panX !== 0 || panY !== 0) {
            canvas2d.relativePan(new fabric.Point(panX, panY));
        }
    }
    
    function handle3DCameraMovement() {
        if(!is3DMode) return;
        const moveSpeed = 15.0;
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
        const moveDirection = new THREE.Vector3(0,0,0);

        if (keyState['w'] || keyState['i']) moveDirection.add(forward);
        if (keyState['s'] || keyState['k']) moveDirection.sub(forward);
        if (keyState['a'] || keyState['j']) moveDirection.sub(right);
        if (keyState['d'] || keyState['l']) moveDirection.add(right);
        
        if(moveDirection.lengthSq() > 0){
            const finalMove = moveDirection.normalize().multiplyScalar(moveSpeed);
            camera.position.add(finalMove);
            controls.target.add(finalMove);
        }

        if (keyState['arrowup']) camera.position.y += moveSpeed;
        if (keyState['arrowdown']) camera.position.y -= moveSpeed;
    }

    // --- Object Insertion ---
    function insertWall() {
        const wall = new fabric.Rect({
            width: document.getElementById('wall-length').value * scale, height: 10, fill: 'black',
            left: 50, top: 50, originX: 'left', originY: 'top', isWall: true, uid: ++uidCounter
        });
        canvas2d.add(wall);
        if (showLengths) updateLengthTextFor(wall);
        canvas2d.requestRenderAll();
    }

    function insertItem() {
        const item = new fabric.Rect({
            width: 600 * scale, height: 600 * scale, fill: '#A52A2A', left: 200, top: 200,
            isItem: true, itemProps: { width: 600, depth: 600, height: 800, y: 0, color: '#A52A2A' }, uid: ++uidCounter
        });
        canvas2d.add(item).requestRenderAll();
    }
    
    function insertDoor() {
        const doorProps = { width: 800, height: 2000, isOpen: false };
        const doorGroup = new fabric.Group([
            new fabric.Rect({ width: doorProps.width * scale, height: 10, fill: 'white', stroke: 'black', strokeWidth: 1, originX: 'center', originY: 'center' })
        ], {
            left: 150, top: 150, isDoor: true, doorProps: doorProps, uid: ++uidCounter, hasControls: false, hasBorders: true
        });
        createDoorArc(doorGroup);
        canvas2d.add(doorGroup).requestRenderAll();
    }

    function insertWindow() {
        const windowProps = { width: 1200, height: 1000, y: 900 };
        const windowGroup = new fabric.Group([
            new fabric.Rect({ width: windowProps.width * scale, height: 10, fill: 'white', stroke: 'black', strokeWidth: 1 }),
            new fabric.Line([0, 5, windowProps.width * scale, 5], { stroke: 'black', strokeWidth: 1 })
        ], {
            left: 150, top: 150, isWindow: true, windowProps: windowProps, uid: ++uidCounter, hasControls: false, hasBorders: true
        });
        canvas2d.add(windowGroup).requestRenderAll();
    }
    
    // --- Menu Update Functions ---
    function updateMenu(e) {
        if (isMeteringMode) return;
        ['selected-object-controls', 'wall-editor-controls', 'item-editor-controls', 'door-editor-controls', 'window-editor-controls'].forEach(id => {
            document.getElementById(id).style.display = 'none';
        });
        
        const activeObjects = canvas2d.getActiveObjects();
        if (activeObjects.length === 0) return;

        document.getElementById('selected-object-controls').style.display = 'block';

        if (activeObjects.length === 1) {
            const obj = activeObjects[0];
            if (obj.isWall) {
                document.getElementById('wall-editor-controls').style.display = 'block';
                document.getElementById('edit-wall-length').value = Math.round(obj.getScaledWidth() / scale);
                document.getElementById('edit-wall-angle').value = Math.round(obj.angle);
            } else if (obj.isItem) {
                document.getElementById('item-editor-controls').style.display = 'block';
                const currentWidthMM = obj.getScaledWidth() / scale;
                const currentDepthMM = obj.getScaledHeight() / scale;
                obj.itemProps.width = currentWidthMM;
                obj.itemProps.depth = currentDepthMM;
                document.getElementById('item-width').value = Math.round(currentWidthMM);
                document.getElementById('item-depth').value = Math.round(currentDepthMM);
                document.getElementById('item-height').value = obj.itemProps.height;
                document.getElementById('item-y-position').value = obj.itemProps.y || 0;
            } else if (obj.isDoor) {
                document.getElementById('door-editor-controls').style.display = 'block';
                document.getElementById('door-width').value = obj.doorProps.width;
                document.getElementById('door-height').value = obj.doorProps.height;
            } else if (obj.isWindow) {
                document.getElementById('window-editor-controls').style.display = 'block';
                document.getElementById('window-width').value = obj.windowProps.width;
                document.getElementById('window-height').value = obj.windowProps.height;
                document.getElementById('window-y-position').value = obj.windowProps.y;
            }
        }
    }
    
    function updateWallFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isWall) return;
        activeObject.set({ width: document.getElementById('edit-wall-length').value * scale, angle: parseFloat(document.getElementById('edit-wall-angle').value) });
        activeObject.scaleX = 1;
        activeObject.setCoords();
        canvas2d.requestRenderAll();
        updateTextForObject(activeObject);
    }
    
    function update3DColorFromMenu() {
        const color = document.getElementById('wall-color').value;
        canvas2d.getActiveObjects().forEach(obj => { if (obj.isWall) obj.color3d = color; });
        if (is3DMode) update3DScene();
    }

    function updateItemFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isItem) return;
        const props = activeObject.itemProps;
        props.width = document.getElementById('item-width').value;
        props.depth = document.getElementById('item-depth').value;
        props.height = document.getElementById('item-height').value;
        props.y = parseFloat(document.getElementById('item-y-position').value) || 0;
        activeObject.set({ width: props.width * scale, height: props.depth * scale, scaleX: 1, scaleY: 1 }).setCoords();
        canvas2d.requestRenderAll();
        if (is3DMode) liveUpdate3DObject(activeObject);
    }
    
    function updateDoorFromMenu() {
        const door = canvas2d.getActiveObject();
        if (!door || !door.isDoor) return;
        door.doorProps.width = parseFloat(document.getElementById('door-width').value);
        door.doorProps.height = parseFloat(document.getElementById('door-height').value);
        door.getObjects()[0].set('width', door.doorProps.width * scale);
        door.addWithUpdate();
        createDoorArc(door);
        canvas2d.requestRenderAll();
        if(is3DMode) update3DScene();
    }
    
    function updateWindowFromMenu() {
        const win = canvas2d.getActiveObject();
        if (!win || !win.isWindow) return;
        win.windowProps.width = parseFloat(document.getElementById('window-width').value);
        win.windowProps.height = parseFloat(document.getElementById('window-height').value);
        win.windowProps.y = parseFloat(document.getElementById('window-y-position').value);
        const rect = win.getObjects()[0];
        const line = win.getObjects()[1];
        rect.set('width', win.windowProps.width * scale);
        line.set('x2', win.windowProps.width * scale);
        win.addWithUpdate();
        canvas2d.requestRenderAll();
        if(is3DMode) update3DScene();
    }

    // --- Object-specific functions ---
    function toggleDoorState() {
        const door = canvas2d.getActiveObject();
        if (!door || !door.isDoor) return;
        door.doorProps.isOpen = !door.doorProps.isOpen;
        if (door.doorArc) door.doorArc.visible = door.doorProps.isOpen;
        canvas2d.requestRenderAll();
        if (is3DMode) liveUpdate3DObject(door);
    }
    
    function createDoorArc(door) {
        if (door.doorArc) canvas2d.remove(door.doorArc);
        const width = door.doorProps.width * scale;
        const path = `M 0 0 A ${width} ${width} 0 0 1 ${width} ${width}`;
        const arc = new fabric.Path(path, {
            stroke: '#888', strokeWidth: 1, fill: '', originX: 'left', originY: 'bottom',
            visible: door.doorProps.isOpen, isDoorArc: true, evented: false
        });
        door.doorArc = arc;
        const updateArc = () => {
            if (!door.doorArc) return;
            const matrix = door.calcTransformMatrix();
            const d = fabric.util.qrDecompose(matrix);
            door.doorArc.set({ left: d.translateX, top: d.translateY, angle: d.angle });
            door.doorArc.setCoords();
        };
        door.on('moving', updateArc);
        door.on('rotating', updateArc);
        updateArc();
        canvas2d.add(arc);
    }
    
    function handleSnapping(obj) {
        let snapped = false;
        for (const wall of canvas2d.getObjects().filter(o => o.isWall)) {
            if (obj.intersectsWithObject(wall)) {
                obj.set({ angle: wall.angle });
                const wallStart = wall.getPointByOrigin('left', 'center');
                const v = new fabric.Point(wall.getScaledWidth(), 0).rotate(fabric.util.degreesToRadians(wall.angle));
                const u = obj.getCenterPoint().subtract(wallStart);
                const dot = u.dot(v.normalize());
                if (dot >= 0 && dot <= wall.getScaledWidth()) {
                    const snappedPoint = wallStart.add(v.normalize().multiply(dot));
                    obj.set({ left: snappedPoint.x, top: snappedPoint.y });
                }
                obj.setCoords();
                obj.parentWallUid = wall.uid;
                snapped = true;
                break;
            }
        }
        if (!snapped) obj.parentWallUid = null;
    }
    
    // --- Length Text Functions ---
    function toggleLengthVisibility() {
        showLengths = !showLengths;
        Object.values(lengthTextObjects).forEach(text => text.visible = showLengths);
        if (showLengths) updateAllLengthTexts();
        canvas2d.requestRenderAll();
    }

    function updateAllLengthTexts() {
        const visibleObjects = new Set();
        canvas2d.getObjects().forEach(obj => {
            if (obj.isWall) {
                updateLengthTextFor(obj);
                visibleObjects.add(obj.uid);
            }
        });
        for (const uid in lengthTextObjects) {
            if (!visibleObjects.has(parseInt(uid))) lengthTextObjects[uid].visible = false;
        }
    }

    function updateLengthTextFor(wall) {
        let textObj = lengthTextObjects[wall.uid];
        if (!textObj) {
            textObj = new fabric.Text('', { fontSize: 12, fill: 'black', originX: 'center', originY: 'center', selectable: false, evented: false, textBaseline: 'middle' });
            lengthTextObjects[wall.uid] = textObj;
            canvas2d.add(textObj);
        }
        textObj.visible = true;
        textObj.text = `${Math.round(wall.getScaledWidth() / scale)} mm`;
        const d = fabric.util.qrDecompose(wall.calcTransformMatrix());
        const center = new fabric.Point(d.translateX, d.translateY);
        const offset = new fabric.Point(0, -20);
        const rotatedOffset = fabric.util.rotatePoint(offset, new fabric.Point(0,0), fabric.util.degreesToRadians(d.angle));
        textObj.set({ left: center.x + rotatedOffset.x, top: center.y + rotatedOffset.y, angle: d.angle });
        textObj.bringToFront();
    }

    // --- Window/View Management ---
    function onWindowResize() {
        const w = canvasContainer.clientWidth, h = canvasContainer.clientHeight;
        canvas2d.setDimensions({ width: w, height: h });
        if (is3DMode) {
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }
    }

    function toggle3DMode() {
        is3DMode = !is3DMode;
        if (is3DMode) {
            document.getElementById('toggle-3d').textContent = 'Switch to 2D';
            canvas2d.getElement().style.display = 'none';
            canvas3d.style.display = 'block';
            if (!renderer) init3D();
            onWindowResize();
            update3DScene();
        } else {
            document.getElementById('toggle-3d').textContent = 'Switch to 3D';
            canvas2d.getElement().style.display = 'block';
            canvas3d.style.display = 'none';
        }
    }

    // --- 3D Scene Management ---
    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 1, 20000);
        camera.position.set(500, 800, 1300);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        canvas3d.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(150, 200, 100);
        scene.add(dirLight);
        const floorGeometry = new THREE.PlaneGeometry(10000, 10000);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: document.getElementById('floor-color').value });
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;
        camera.lookAt(controls.target);
    }
    
    function update3DScene() {
        Object.values(sceneObjects3D).forEach(obj => {
            obj.geometry?.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                else obj.material.dispose();
            }
            if (obj.children) {
                obj.children.forEach(child => {
                    child.geometry?.dispose();
                    child.material?.dispose();
                });
            }
            scene.remove(obj);
        });
        sceneObjects3D = {};
        if(floor) floor.material.color.set(document.getElementById('floor-color').value);
        
        const objects2D = canvas2d.getObjects().filter(o => !o.isLengthText && !o.isMeteringObject && !o.isDoorArc);
        const walls = objects2D.filter(o => o.isWall);
        const openings = objects2D.filter(o => o.isDoor || o.isWindow);

        walls.forEach(wall2d => {
            const wallMesh = createMeshAtWorldPosition(wall2d);
            wallMesh.updateMatrixWorld(true);
            let wallCSG = CSG.fromMesh(wallMesh);
            
            const wallOpenings = openings.filter(o => o.parentWallUid === wall2d.uid);
            wallOpenings.forEach(opening2d => {
                const cutterMesh = createCutterAtWorldPosition(opening2d);
                cutterMesh.updateMatrixWorld(true);
                const cutterCSG = CSG.fromMesh(cutterMesh);
                wallCSG = wallCSG.subtract(cutterCSG);
            });

            const finalMesh = CSG.toMesh(wallCSG, wallMesh.matrix);
            finalMesh.material = wallMesh.material;
            
            sceneObjects3D[wall2d.uid] = finalMesh;
            scene.add(finalMesh);
        });

        openings.forEach(opening2d => {
            if (opening2d.parentWallUid) {
                if(opening2d.isDoor) create3DDoor(opening2d);
                if(opening2d.isWindow) create3DWindow(opening2d);
            }
        });
        objects2D.filter(o => o.isItem).forEach(item2d => create3DItem(item2d));
    }

    function createMeshAtWorldPosition(obj2d) {
        const wallHeight = parseFloat(document.getElementById('wall-height').value) * scale;
        const geometry = new THREE.BoxGeometry(obj2d.getScaledWidth(), wallHeight, obj2d.getScaledHeight());
        const material = new THREE.MeshStandardMaterial({ color: obj2d.color3d || '#ffffff' });
        const mesh3d = new THREE.Mesh(geometry, material);
        const d = fabric.util.qrDecompose(obj2d.calcTransformMatrix());
        mesh3d.position.set(d.translateX - canvas2d.width / 2, wallHeight / 2, d.translateY - canvas2d.height / 2);
        mesh3d.rotation.y = -fabric.util.degreesToRadians(d.angle);
        return mesh3d;
    }

    function createCutterAtWorldPosition(opening2d) {
        const props = opening2d.isDoor ? opening2d.doorProps : opening2d.windowProps;
        const width = (props.width || 800) * scale;
        const height = (props.height || 2000) * scale;
        const yPos = (props.y || 0) * scale;
        const cutterGeo = new THREE.BoxGeometry(width, height, 50);
        const cutterMat = new THREE.MeshBasicMaterial();
        const cutterMesh = new THREE.Mesh(cutterGeo, cutterMat);
        const d = fabric.util.qrDecompose(opening2d.calcTransformMatrix());
        cutterMesh.position.set(d.translateX - canvas2d.width / 2, yPos + height / 2, d.translateY - canvas2d.height / 2);
        cutterMesh.rotation.y = -fabric.util.degreesToRadians(d.angle);
        return cutterMesh;
    }
    
    function create3DDoor(door2d) {
        const props = door2d.doorProps;
        const d = fabric.util.qrDecompose(door2d.calcTransformMatrix());
        const doorGroup = new THREE.Group();
        const doorPanelGeo = new THREE.BoxGeometry(props.width * scale, props.height * scale, 4);
        const doorPanelMat = new THREE.MeshStandardMaterial({ color: '#8B4513' });
        const doorPanel = new THREE.Mesh(doorPanelGeo, doorPanelMat);
        doorPanel.position.x = -props.width * scale / 2;
        const pivot = new THREE.Group();
        pivot.add(doorPanel);
        if (props.isOpen) pivot.rotation.y = Math.PI / 2;
        doorGroup.add(pivot);
        doorGroup.position.set(d.translateX - canvas2d.width / 2, (props.height * scale) / 2, d.translateY - canvas2d.height / 2);
        doorGroup.rotation.y = -fabric.util.degreesToRadians(d.angle);
        sceneObjects3D[door2d.uid] = doorGroup;
        scene.add(doorGroup);
    }

    function create3DWindow(window2d) {
        const props = window2d.windowProps;
        const d = fabric.util.qrDecompose(window2d.calcTransformMatrix());
        const windowGroup = new THREE.Group();
        const frameMat = new THREE.MeshStandardMaterial({ color: '#CCCCCC' });
        const glassMat = new THREE.MeshStandardMaterial({ color: '#87CEEB', transparent: true, opacity: 0.3 });
        const w = props.width * scale;
        const h = props.height * scale;
        const t = 10;
        const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), frameMat);
        topFrame.position.y = h/2 - t/2;
        const bottomFrame = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), frameMat);
        bottomFrame.position.y = -h/2 + t/2;
        const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(t, h, t), frameMat);
        leftFrame.position.x = -w/2 + t/2;
        const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(t, h, t), frameMat);
        rightFrame.position.x = w/2 - t/2;
        const glass = new THREE.Mesh(new THREE.BoxGeometry(w-t, h-t, 1), glassMat);
        windowGroup.add(topFrame, bottomFrame, leftFrame, rightFrame, glass);
        windowGroup.position.set(d.translateX - canvas2d.width / 2, (props.height * scale) / 2 + (props.y * scale), d.translateY - canvas2d.height / 2);
        windowGroup.rotation.y = -fabric.util.degreesToRadians(d.angle);
        sceneObjects3D[window2d.uid] = windowGroup;
        scene.add(windowGroup);
    }
    
    function create3DItem(item2d) {
        const props = item2d.itemProps;
        const geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
        const material = new THREE.MeshStandardMaterial({ color: props.color });
        const item3d = new THREE.Mesh(geometry, material);
        const center = item2d.getCenterPoint();
        item3d.position.set(center.x - canvas2d.width/2, (props.height * scale)/2 + ((props.y || 0) * scale), center.y - canvas2d.height/2);
        item3d.rotation.y = -fabric.util.degreesToRadians(item2d.angle);
        sceneObjects3D[item2d.uid] = item3d;
        scene.add(item3d);
    }

    function liveUpdate3DObject(obj2d) {
        const mesh3d = sceneObjects3D[obj2d.uid];
        if (!mesh3d) return;
        if (obj2d.isItem) {
            const props = obj2d.itemProps;
            mesh3d.geometry.dispose();
            mesh3d.geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
            mesh3d.position.y = (props.height * scale) / 2 + (props.y * scale);
        } else if (obj2d.isDoor) {
            mesh3d.children[0].rotation.y = obj2d.doorProps.isOpen ? Math.PI / 2 : 0;
        }
    }

    // --- Main Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        if (is3DMode) {
            handle3DCameraMovement();
            controls.update();
            renderer.render(scene, camera);
        } else {
            handle2DPan();
            canvas2d.renderAll();
        }
    }

    // --- Metering Functions ---
    
    function toggleMeteringMode() {
        const btn = document.getElementById('metering-button');
        isMeteringMode = !isMeteringMode;
        if (isMeteringMode) {
            btn.textContent = 'Cancel Metering';
            btn.classList.add('active');
            clearMetering();
            canvas2d.selection = false;
            canvas2d.forEachObject(o => o.set('evented', false));
        } else {
            btn.textContent = 'Start Metering';
            btn.classList.remove('active');
            clearMetering();
            canvas2d.selection = true;
            canvas2d.forEachObject(o => o.set('evented', true));
        }
    }

    function clearMetering() {
        canvas2d.remove(...meteringObjects);
        meteringObjects = [];
        meteringPoints = [];
        canvas2d.requestRenderAll();
    }

    function handleMouseDown(opt) {
        if (!isMeteringMode) return;
        const pointer = canvas2d.getPointer(opt.e);
        if (meteringPoints.length > 2) {
            const startPoint = meteringPoints[0];
            const dist = Math.sqrt(Math.pow(startPoint.x - pointer.x, 2) + Math.pow(startPoint.y - pointer.y, 2));
            if (dist < 10) {
                drawMeteringLine(meteringPoints[meteringPoints.length - 1], startPoint);
                calculateAndShowArea();
                isMeteringMode = false; 
                return;
            }
        }
        meteringPoints.push(pointer);
        const circle = new fabric.Circle({ radius: 3, fill: 'red', left: pointer.x, top: pointer.y, originX: 'center', originY: 'center', isMeteringObject: true });
        meteringObjects.push(circle);
        canvas2d.add(circle);
        if (meteringPoints.length > 1) {
            drawMeteringLine(meteringPoints[meteringPoints.length - 2], pointer);
        }
    }

    function drawMeteringLine(p1, p2) {
        const line = new fabric.Line([p1.x, p1.y, p2.x, p2.y], { stroke: 'red', strokeWidth: 2, selectable: false, evented: false, isMeteringObject: true });
        meteringObjects.push(line);
        canvas2d.add(line);
        const lengthPx = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        const lengthMM = lengthPx / scale;
        const text = new fabric.Text(`${Math.round(lengthMM)} mm`, { left: (p1.x + p2.x) / 2, top: (p1.y + p2.y) / 2, fontSize: 14, fill: 'black', originX: 'center', originY: 'center', isMeteringObject: true, textBaseline: 'middle' });
        meteringObjects.push(text);
        canvas2d.add(text);
    }
    
    function calculateAndShowArea() {
        let areaPx = 0;
        for (let i = 0; i < meteringPoints.length; i++) {
            const p1 = meteringPoints[i];
            const p2 = meteringPoints[(i + 1) % meteringPoints.length];
            areaPx += (p1.x * p2.y - p2.x * p1.y);
        }
        areaPx = Math.abs(areaPx) / 2;
        const mPerPx = 1 / scale / 1000;
        const areaM2 = areaPx * mPerPx * mPerPx;
        let centroid = { x: 0, y: 0 };
        meteringPoints.forEach(p => { centroid.x += p.x; centroid.y += p.y; });
        centroid.x /= meteringPoints.length;
        centroid.y /= meteringPoints.length;
        const areaText = new fabric.Text(`${areaM2.toFixed(2)} m²`, { left: centroid.x, top: centroid.y, fontSize: 16, fill: 'blue', fontWeight: 'bold', originX: 'center', originY: 'center', isMeteringObject: true, textBaseline: 'middle' });
        meteringObjects.push(areaText);
        canvas2d.add(areaText);
    }

    // Initial setup
    updateAllLengthTexts();
    canvas2d.requestRenderAll();
    animate();
</script>

</body>
</html>