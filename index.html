<!DOCTYPE html>
<html>
<head>
    <title>2D/3D Room Planner</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            overflow: hidden; /* Prevent scrollbars */
        }
        #menu {
            width: 250px;
            padding: 20px;
            background-color: #f0f0f0;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            height: 100vh;
            z-index: 10;
        }
        #menu h3 { margin-top: 0; }
        #menu .input-group { margin-bottom: 15px; }
        #menu label { display: block; margin-bottom: 5px; }
        #menu input, #menu button {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        #menu button {
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        #menu button:hover { background-color: #0056b3; }
        #menu .control-section button, #menu #metering-button.active, #menu #draw-walls-button.active, #menu #remove-texture-button, #menu #remove-floor-texture-button { background-color: #dc3545; }
        #menu .control-section button:hover, #menu #metering-button.active:hover, #menu #draw-walls-button.active:hover, #menu #remove-texture-button:hover, #menu #remove-floor-texture-button:hover { background-color: #c82333; }
        #menu #load-button, #menu #save-screenshot-button, #menu #apply-texture-button, #menu #apply-floor-texture-button { background-color: #28a745; }
        #menu #load-button:hover, #menu #save-screenshot-button:hover, #menu #apply-texture-button:hover, #menu #apply-floor-texture-button:hover { background-color: #218838; }
        #menu #info-button { background-color: #17a2b8; }
        #menu #info-button:hover { background-color: #138496; }

        #canvas-container {
            flex-grow: 1;
            position: relative;
        }
        #canvas-2d, #canvas-3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Info Modal */
        #info-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }
        .info-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
        }
        .info-content h2 { margin-top: 0; }
        .info-content ul { list-style-type: none; padding-left: 0;}
        .info-content li { margin-bottom: 10px; }
        .info-content kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-family: monospace;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="menu">
    <h3>File</h3>
    <button id="save-button">Save to File</button>
    <button id="load-button" onclick="document.getElementById('file-input').click()">Load from File</button>
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <button id="save-screenshot-button">Save Screenshot (JPG)</button>
    <hr>
    <h3>Insert</h3>
    <div class="input-group">
        <label for="wall-length">Wall Length (mm):</label>
        <input type="number" id="wall-length" value="4000">
    </div>
    <button id="insert-wall">Insert Wall</button>
    <button id="draw-walls-button">Draw Walls</button>
    <button id="insert-item">Insert Item (Cube)</button>
    <hr>
    <h3>Controls</h3>
    <button id="metering-button">Start Metering</button>
    <button id="toggle-lengths">Show/Hide Lengths</button>
    <button id="info-button">Show Controls Info</button>

    <div id="selected-object-controls" class="control-section" style="display: none;">
        <hr><h3>Selected Object</h3>
        <button id="remove-object">Remove Selected</button>
        <button id="apply-texture-button" onclick="document.getElementById('texture-file-input').click()">Apply Texture</button>
        <button id="remove-texture-button">Remove Texture</button>
        <input type="file" id="texture-file-input" style="display: none;" accept=".jpg,.jpeg,.png">
        <!-- Wall-specific controls -->
        <div id="wall-editor-controls" style="display: none;">
            <div class="input-group">
                <label for="edit-wall-length">Length (mm):</label>
                <input type="number" id="edit-wall-length">
            </div>
            <div class="input-group">
                <label for="edit-wall-angle">Angle (°):</label>
                <input type="number" id="edit-wall-angle">
            </div>
        </div>
        <!-- Item-specific controls -->
        <div id="item-editor-controls" style="display: none;">
            <div class="input-group"><label for="item-width">Width (mm):</label><input type="number" id="item-width"></div>
            <div class="input-group"><label for="item-depth">Depth (mm):</label><input type="number" id="item-depth"></div>
            <div class="input-group"><label for="item-height">Height (mm):</label><input type="number" id="item-height"></div>
            <div class="input-group"><label for="item-y-position">Vertical Position (mm):</label><input type="number" id="item-y-position"></div>
        </div>
    </div>
    
    <hr>
    <h3>3D View</h3>
    <button id="toggle-3d">Switch to 3D</button>
    <div id="view-controls">
        <div class="input-group">
            <label for="wall-color">Selected Wall 3D Color:</label>
            <input type="color" id="wall-color" value="#ffffff">
        </div>
        <div class="input-group">
            <label for="floor-color">Floor Color:</label>
            <input type="color" id="floor-color" value="#808080">
        </div>
        <button id="apply-floor-texture-button" onclick="document.getElementById('floor-texture-file-input').click()">Apply Floor Texture</button>
        <button id="remove-floor-texture-button">Remove Floor Texture</button>
        <input type="file" id="floor-texture-file-input" style="display: none;" accept=".jpg,.jpeg,.png">
        <div class="input-group">
            <label for="wall-height">Default Wall Height (mm):</label>
            <input type="number" id="wall-height" value="2400">
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas-2d"></canvas>
    <div id="canvas-3d" style="display: none;"></div>
</div>

<div id="info-modal">
    <div class="info-content">
        <span class="close-button">×</span>
        <h2>Controls Guide</h2>
        <h3>2D Mode</h3>
        <ul>
            <li><b>Pan View:</b> <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> keys.</li>
            <li><b>Zoom:</b> Mouse Wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Select/Move/Rotate:</b> Click and drag objects. Use rotation handles.</li>
            <li><b>Multi-Select:</b> Hold <kbd>Shift</kbd> and click multiple objects.</li>
            <li><b>Delete Object:</b> Select an object and press <kbd>Delete</kbd> or <kbd>Backspace</kbd>.</li>
            <li><b>Draw Walls:</b> Activate drawing mode, then click on the canvas to place wall corners. Press <kbd>Esc</kbd> or click the button again to finish.</li>
            <li><b>Metering:</b> Activate metering mode, then click on the canvas to draw a measuring line. Click near the start point to close the loop and calculate area.</li>
        </ul>
        <h3>3D Mode</h3>
        <ul>
            <li><b>Rotate View:</b> Click and drag with the left mouse button.</li>
            <li><b>Pan View:</b> Click and drag with the right mouse button.</li>
            <li><b>Zoom:</b> Use the mouse wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Move Camera (Walk):</b> <kbd>W</kbd> (forward), <kbd>A</kbd> (left), <kbd>S</kbd> (back), <kbd>D</kbd> (right).</li>
            <li><b>Move Camera (Strafe):</b> <kbd>I</kbd> (forward), <kbd>K</kbd> (back), <kbd>J</kbd> (left), <kbd>L</kbd> (right).</li>
            <li><b>Move Camera (Vertical):</b> <kbd>↑</kbd> (up), <kbd>↓</kbd> (down).</li>
        </ul>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const canvasContainer = document.getElementById('canvas-container');
    const scale = 0.1;
    let showLengths = true;
    const keyState = {};
    let uidCounter = 0;

    // --- 2D Canvas ---
    const canvas2d = new fabric.Canvas('canvas-2d', {
        width: canvasContainer.clientWidth,
        height: canvasContainer.clientHeight,
        backgroundColor: 'white',
        preserveObjectStacking: true,
        renderOnAddRemove: false
    });
    const customProps = ['isWall', 'isItem', 'itemProps', 'uid', 'color3d', 'textureURL'];
    let lengthTextObjects = {};

    // --- Mode States ---
    let isMeteringMode = false;
    let meteringPoints = [];
    let meteringObjects = [];
    
    let isDrawingWallsMode = false;
    let wallDrawingPoints = [];
    let previewLine = null;

    // --- 3D Scene ---
    let scene, camera, renderer, controls;
    let floor;
    let sceneObjects3D = {};
    const canvas3d = document.getElementById('canvas-3d');
    let is3DMode = false;
    let floorTextureURL = null;
    
    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
        const activeEl = document.activeElement;
        if(activeEl.tagName !== 'INPUT') {
            keyState[e.key.toLowerCase()] = true;
            handleGlobalKeys(e);
        }
    });
    document.addEventListener('keyup', (e) => keyState[e.key.toLowerCase()] = false);
    
    document.getElementById('save-button').addEventListener('click', saveToFile);
    document.getElementById('file-input').addEventListener('change', loadFromFile);
    document.getElementById('texture-file-input').addEventListener('change', applyTexture);
    document.getElementById('remove-texture-button').addEventListener('click', removeObjectTexture);
    document.getElementById('floor-texture-file-input').addEventListener('change', applyFloorTexture);
    document.getElementById('remove-floor-texture-button').addEventListener('click', removeFloorTexture);
    document.getElementById('save-screenshot-button').addEventListener('click', saveScreenshot);
    document.getElementById('info-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'block');
    document.querySelector('.close-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'none');
    window.addEventListener('click', (e) => { if (e.target == document.getElementById('info-modal')) e.target.style.display = 'none'; });
    
    document.getElementById('insert-wall').addEventListener('click', insertWall);
    document.getElementById('draw-walls-button').addEventListener('click', toggleDrawWallsMode);
    document.getElementById('insert-item').addEventListener('click', insertItem);
    document.getElementById('remove-object').addEventListener('click', removeSelectedObject);
    document.getElementById('toggle-lengths').addEventListener('click', toggleLengthVisibility);
    document.getElementById('toggle-3d').addEventListener('click', toggle3DMode);
    document.getElementById('metering-button').addEventListener('click', toggleMeteringMode);

    document.getElementById('edit-wall-length').addEventListener('input', updateWallFromMenu);
    document.getElementById('edit-wall-angle').addEventListener('input', updateWallFromMenu);
    document.getElementById('wall-color').addEventListener('input', update3DColorFromMenu);
    
    ['item-width', 'item-depth', 'item-height', 'item-y-position'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateItemFromMenu);
    });

    window.addEventListener('resize', onWindowResize);
    
    // --- Canvas Event Listeners ---
    function updateTextForObject(obj) {
        if (!showLengths || !obj) return;
        if (obj.isWall) updateLengthTextFor(obj);
    }

    canvas2d.on({
        'mouse:wheel': handle2DZoom,
        'mouse:down': handleMouseDown,
        'mouse:move': handleMouseMove,
        'selection:created': updateMenu,
        'selection:updated': updateMenu,
        'selection:cleared': updateMenu,
        'object:modified': (e) => updateMenu(e),
        'object:moving': (e) => updateTextForObject(e.target),
        'object:rotating': (e) => updateTextForObject(e.target),
        'object:scaling': (e) => updateTextForObject(e.target)
    });

    // --- Core Functions ---

    function removeSelectedObject() {
        canvas2d.getActiveObjects().forEach(activeObject => {
            if (lengthTextObjects[activeObject.uid]) {
                canvas2d.remove(lengthTextObjects[activeObject.uid]);
                delete lengthTextObjects[activeObject.uid];
            }
            if (sceneObjects3D[activeObject.uid]) {
                scene.remove(sceneObjects3D[activeObject.uid]);
                delete sceneObjects3D[activeObject.uid];
            }
            canvas2d.remove(activeObject);
        });
        canvas2d.discardActiveObject();
        canvas2d.requestRenderAll();
    }

    function saveToFile() {
        const originalObjects = canvas2d.getObjects().filter(o => !o.isLengthText && !o.isMeteringObject && !o.isWallPoint);
        const json = canvas2d.toObject(customProps);
        json.objects = originalObjects.map(o => o.toObject(customProps));
        json.floorTextureURL = floorTextureURL;
        
        const dataStr = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(json, null, 2))}`;
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "plan.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    function saveScreenshot() {
        let dataUrl;
        if (is3DMode) {
            renderer.render(scene, camera); // Ensure scene is rendered before capture
            dataUrl = renderer.domElement.toDataURL('image/jpeg');
        } else {
            dataUrl = canvas2d.toDataURL({
                format: 'jpeg',
                quality: 0.9
            });
        }
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = "screenshot.jpg";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    function loadFromFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            const data = JSON.parse(f.target.result);
            
            floorTextureURL = data.floorTextureURL || null;

            canvas2d.loadFromJSON(data, () => {
                canvas2d.getObjects().forEach(obj => {
                    if (obj.uid === undefined) obj.uid = ++uidCounter;
                });
                updateAllLengthTexts();
                canvas2d.requestRenderAll();

                if (is3DMode) {
                    update3DScene();
                }
            });
        };
        reader.readAsText(file);
        e.target.value = '';
    }
    
    function applyTexture(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (f) => {
            const dataURL = f.target.result;
            const activeObjects = canvas2d.getActiveObjects();

            if (activeObjects.length === 0) return;
            
            activeObjects.forEach(obj => {
                obj.textureURL = dataURL;
            });

            if (is3DMode) {
                update3DScene();
            }
        };
        reader.readAsDataURL(file);
        e.target.value = '';
    }

    function removeObjectTexture() {
        const activeObjects = canvas2d.getActiveObjects();
        if (activeObjects.length === 0) return;

        activeObjects.forEach(obj => {
            obj.textureURL = null;
        });

        if (is3DMode) {
            update3DScene();
        }
    }
    
    function applyFloorTexture(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (f) => {
            floorTextureURL = f.target.result;
            if (is3DMode) {
                update3DScene();
            }
        };
        reader.readAsDataURL(file);
        e.target.value = '';
    }

    function removeFloorTexture() {
        floorTextureURL = null;
        if (is3DMode) {
            update3DScene();
        }
    }

    function handleGlobalKeys(e) {
        const key = e.key.toLowerCase();
        
        if (key === 'escape') {
            if (isDrawingWallsMode) toggleDrawWallsMode();
            if (isMeteringMode) toggleMeteringMode();
        }

        if (key === 'backspace' || key === 'delete') {
            e.preventDefault(); // Prevent browser back navigation on backspace
            removeSelectedObject();
        }

        if (key === 'r' || key === 'f') {
            e.preventDefault();
            const zoomFactor = 1.1;
            const zoom = key === 'r' ? zoomFactor : 1 / zoomFactor;
            if (is3DMode) {
                 const forward = new THREE.Vector3();
                 camera.getWorldDirection(forward);
                 camera.position.addScaledVector(forward, (1 - 1/zoom) * 1000);
            } else {
                canvas2d.zoomToPoint(new fabric.Point(canvas2d.width / 2, canvas2d.height / 2), canvas2d.getZoom() * zoom);
            }
        }
    }

    function handle2DZoom(opt) {
        if (isMeteringMode || isDrawingWallsMode) return;
        opt.e.preventDefault();
        opt.e.stopPropagation();
        const delta = opt.e.deltaY;
        let zoom = canvas2d.getZoom();
        zoom *= 0.999 ** delta;
        if (zoom > 20) zoom = 20;
        if (zoom < 0.1) zoom = 0.1;
        canvas2d.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
    }

    function handle2DPan() {
        if(is3DMode) return;
        const panSpeed = 15 / canvas2d.getZoom();
        let panX = 0, panY = 0;
        if (keyState['w']) panY += panSpeed;
        if (keyState['s']) panY -= panSpeed;
        if (keyState['a']) panX += panSpeed;
        if (keyState['d']) panX -= panSpeed;

        if (panX !== 0 || panY !== 0) {
            canvas2d.relativePan(new fabric.Point(panX, panY));
        }
    }
    
    function handle3DCameraMovement() {
        if(!is3DMode) return;
        const moveSpeed = 15.0;
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
        const moveDirection = new THREE.Vector3(0,0,0);

        if (keyState['w'] || keyState['i']) moveDirection.add(forward);
        if (keyState['s'] || keyState['k']) moveDirection.sub(forward);
        if (keyState['a'] || keyState['j']) moveDirection.sub(right);
        if (keyState['d'] || keyState['l']) moveDirection.add(right);
        
        if(moveDirection.lengthSq() > 0){
            const finalMove = moveDirection.normalize().multiplyScalar(moveSpeed);
            camera.position.add(finalMove);
            controls.target.add(finalMove);
        }

        if (keyState['arrowup']) camera.position.y += moveSpeed;
        if (keyState['arrowdown']) camera.position.y -= moveSpeed;
    }

    function insertWall() {
        const length = document.getElementById('wall-length').value;
        const wall = new fabric.Rect({
            width: length * scale, height: 10, fill: 'black', left: 50, top: 50,
            originX: 'left', originY: 'center', isWall: true, uid: ++uidCounter
        });
        canvas2d.add(wall);

        if (showLengths) {
            updateLengthTextFor(wall);
        }
        
        canvas2d.requestRenderAll();
    }

    function insertItem() {
        const item = new fabric.Rect({
            width: 600 * scale, height: 600 * scale, fill: '#A52A2A', left: 200, top: 200,
            isItem: true, 
            itemProps: { width: 600, depth: 600, height: 800, y: 0, color: '#A52A2A' }, 
            uid: ++uidCounter
        });
        canvas2d.add(item).requestRenderAll();
    }

    function updateMenu(e) {
        if (isMeteringMode || isDrawingWallsMode) return;
        document.getElementById('selected-object-controls').style.display = 'none';
        document.getElementById('wall-editor-controls').style.display = 'none';
        document.getElementById('item-editor-controls').style.display = 'none';
        
        const activeObjects = canvas2d.getActiveObjects();
        if (activeObjects.length === 0) return;

        document.getElementById('selected-object-controls').style.display = 'block';

        if (activeObjects.length === 1) {
            const obj = activeObjects[0];
            if (obj.isWall) {
                document.getElementById('wall-editor-controls').style.display = 'block';
                document.getElementById('edit-wall-length').value = Math.round(obj.getScaledWidth() / scale);
                document.getElementById('edit-wall-angle').value = Math.round(obj.angle);
            } else if (obj.isItem) {
                document.getElementById('item-editor-controls').style.display = 'block';
                
                const currentWidthMM = obj.getScaledWidth() / scale;
                const currentDepthMM = obj.getScaledHeight() / scale;
                obj.itemProps.width = currentWidthMM;
                obj.itemProps.depth = currentDepthMM;
                
                document.getElementById('item-width').value = Math.round(currentWidthMM);
                document.getElementById('item-depth').value = Math.round(currentDepthMM);
                document.getElementById('item-height').value = obj.itemProps.height;
                document.getElementById('item-y-position').value = obj.itemProps.y || 0;
            }
        }
    }
    
    function updateWallFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isWall) return;

        const newLength = document.getElementById('edit-wall-length').value;
        const newAngle = document.getElementById('edit-wall-angle').value;

        activeObject.set({
            width: newLength * scale,
            angle: parseFloat(newAngle)
        });
        activeObject.scaleX = 1;
        activeObject.setCoords();
        canvas2d.requestRenderAll();
        updateTextForObject(activeObject);
    }
    
    function update3DColorFromMenu() {
        const color = document.getElementById('wall-color').value;
        canvas2d.getActiveObjects().forEach(obj => {
            if (obj.isWall) obj.color3d = color;
        });
        if (is3DMode) update3DScene();
    }

    function updateItemFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isItem) return;
        
        const props = activeObject.itemProps;
        props.width = document.getElementById('item-width').value;
        props.depth = document.getElementById('item-depth').value;
        props.height = document.getElementById('item-height').value;
        props.y = parseFloat(document.getElementById('item-y-position').value) || 0;

        activeObject.set({
            width: props.width * scale,
            height: props.depth * scale,
            scaleX: 1,
            scaleY: 1
        }).setCoords();
        
        canvas2d.requestRenderAll();
        
        if (is3DMode) {
            const mesh3d = sceneObjects3D[activeObject.uid];
            if (mesh3d) {
                mesh3d.geometry.dispose();
                mesh3d.geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
                mesh3d.position.y = (props.height * scale) / 2 + (props.y * scale);
            }
        }
    }
    
    function toggleLengthVisibility() {
        showLengths = !showLengths;
        Object.values(lengthTextObjects).forEach(text => text.visible = showLengths);
        if (showLengths) updateAllLengthTexts();
        canvas2d.requestRenderAll();
    }

    function updateAllLengthTexts() {
        const visibleObjects = new Set();
        canvas2d.getObjects().forEach(obj => {
            if (obj.isWall) {
                updateLengthTextFor(obj);
                visibleObjects.add(obj.uid);
            }
        });
        for (const uid in lengthTextObjects) {
            if (!visibleObjects.has(parseInt(uid))) lengthTextObjects[uid].visible = false;
        }
    }

    function updateLengthTextFor(wall) {
        let textObj = lengthTextObjects[wall.uid];
        if (!textObj) {
            textObj = new fabric.Text('', { fontSize: 12, fill: 'black', originX: 'center', originY: 'center', selectable: false, evented: false });
            lengthTextObjects[wall.uid] = textObj;
            canvas2d.add(textObj);
        }

        textObj.visible = true;
        textObj.text = `${Math.round(wall.getScaledWidth() / scale)} mm`;
        const d = fabric.util.qrDecompose(wall.calcTransformMatrix());
        const center = new fabric.Point(d.translateX, d.translateY);
        const offset = new fabric.Point(0, -20);
        const rotatedOffset = fabric.util.rotatePoint(offset, new fabric.Point(0,0), fabric.util.degreesToRadians(d.angle));
        
        textObj.set({
            left: center.x + rotatedOffset.x,
            top: center.y + rotatedOffset.y,
            angle: d.angle
        });
        textObj.bringToFront();
    }

    function onWindowResize() {
        const w = canvasContainer.clientWidth, h = canvasContainer.clientHeight;
        canvas2d.setDimensions({ width: w, height: h });
        if (is3DMode) {
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }
    }

    function toggle3DMode() {
        is3DMode = !is3DMode;
        if (is3DMode) {
            document.getElementById('toggle-3d').textContent = 'Switch to 2D';
            canvas2d.getElement().style.display = 'none';
            canvas3d.style.display = 'block';
            if (!renderer) init3D();
            onWindowResize();
            update3DScene();
        } else {
            document.getElementById('toggle-3d').textContent = 'Switch to 3D';
            canvas2d.getElement().style.display = 'block';
            canvas3d.style.display = 'none';
        }
    }
    
    // --- Interaction Mode Toggles ---

    function setCanvasInteraction(enabled) {
        canvas2d.selection = enabled;
        canvas2d.forEachObject(o => o.set('evented', enabled));
    }

    // --- Wall Drawing Functions ---
    
    function toggleDrawWallsMode() {
        const btn = document.getElementById('draw-walls-button');
        isDrawingWallsMode = !isDrawingWallsMode;
        
        if (isDrawingWallsMode) {
            if(isMeteringMode) toggleMeteringMode(); // Turn off other modes
            btn.textContent = 'Finish Drawing';
            btn.classList.add('active');
            setCanvasInteraction(false);
        } else {
            btn.textContent = 'Draw Walls';
            btn.classList.remove('active');
            setCanvasInteraction(true);
            wallDrawingPoints = [];
            if(previewLine) canvas2d.remove(previewLine);
            previewLine = null;
            canvas2d.requestRenderAll();
        }
    }

    function createWallSegment(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = fabric.util.radiansToDegrees(Math.atan2(dy, dx));

        const wall = new fabric.Rect({
            left: p1.x,
            top: p1.y,
            width: length,
            height: 10,
            angle: angle,
            fill: 'black',
            originX: 'left',
            originY: 'center',
            isWall: true,
            uid: ++uidCounter
        });

        canvas2d.add(wall);
        updateLengthTextFor(wall);
    }
    
    // --- Metering Functions ---
    
    function toggleMeteringMode() {
        const btn = document.getElementById('metering-button');
        isMeteringMode = !isMeteringMode;
        if (isMeteringMode) {
            if(isDrawingWallsMode) toggleDrawWallsMode(); // Turn off other modes
            btn.textContent = 'Cancel Metering';
            btn.classList.add('active');
            clearMetering(); // Clear any previous measurement
            setCanvasInteraction(false);
        } else {
            btn.textContent = 'Start Metering';
            btn.classList.remove('active');
            clearMetering();
            setCanvasInteraction(true);
        }
    }

    function clearMetering() {
        canvas2d.remove(...meteringObjects);
        meteringObjects = [];
        meteringPoints = [];
        canvas2d.requestRenderAll();
    }

    function handleMouseMove(opt) {
        if (!isDrawingWallsMode || wallDrawingPoints.length === 0) return;

        if (previewLine) {
            canvas2d.remove(previewLine);
        }

        const pointer = canvas2d.getPointer(opt.e);
        const startPoint = wallDrawingPoints[wallDrawingPoints.length - 1];
        
        previewLine = new fabric.Line([startPoint.x, startPoint.y, pointer.x, pointer.y], {
            stroke: 'rgba(0,0,0,0.3)',
            strokeWidth: 2,
            selectable: false,
            evented: false,
            strokeDashArray: [5, 5]
        });
        canvas2d.add(previewLine);
        canvas2d.requestRenderAll();
    }

    function handleMouseDown(opt) {
        if(isDrawingWallsMode) {
            const pointer = canvas2d.getPointer(opt.e);
            wallDrawingPoints.push(pointer);

            if (wallDrawingPoints.length > 1) {
                const startPoint = wallDrawingPoints[wallDrawingPoints.length - 2];
                const endPoint = wallDrawingPoints[wallDrawingPoints.length - 1];
                createWallSegment(startPoint, endPoint);
            }
            return;
        }

        if (!isMeteringMode) return;
        const pointer = canvas2d.getPointer(opt.e);

        // Check for loop close
        if (meteringPoints.length > 2) {
            const startPoint = meteringPoints[0];
            const dist = Math.sqrt(Math.pow(startPoint.x - pointer.x, 2) + Math.pow(startPoint.y - pointer.y, 2));
            if (dist < 10) { // Close loop if click is near start point
                drawMeteringLine(meteringPoints[meteringPoints.length - 1], startPoint);
                calculateAndShowArea();
                isMeteringMode = false; // End metering session
                return;
            }
        }

        meteringPoints.push(pointer);
        const circle = new fabric.Circle({
            radius: 3, fill: 'red', left: pointer.x, top: pointer.y,
            originX: 'center', originY: 'center', isMeteringObject: true
        });
        meteringObjects.push(circle);
        canvas2d.add(circle);

        if (meteringPoints.length > 1) {
            const prevPoint = meteringPoints[meteringPoints.length - 2];
            drawMeteringLine(prevPoint, pointer);
        }
    }

    function drawMeteringLine(p1, p2) {
        const line = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
            stroke: 'red', strokeWidth: 2, selectable: false, evented: false, isMeteringObject: true
        });
        meteringObjects.push(line);
        canvas2d.add(line);
        
        // Add length text
        const lengthPx = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        const lengthMM = lengthPx / scale;
        const text = new fabric.Text(`${Math.round(lengthMM)} mm`, {
            left: (p1.x + p2.x) / 2,
            top: (p1.y + p2.y) / 2,
            fontSize: 14,
            fill: 'black',
            originX: 'center',
            originY: 'center',
            isMeteringObject: true
        });
        meteringObjects.push(text);
        canvas2d.add(text);
    }
    
    function calculateAndShowArea() {
        // Shoelace formula for area in pixels
        let areaPx = 0;
        for (let i = 0; i < meteringPoints.length; i++) {
            const p1 = meteringPoints[i];
            const p2 = meteringPoints[(i + 1) % meteringPoints.length];
            areaPx += (p1.x * p2.y - p2.x * p1.y);
        }
        areaPx = Math.abs(areaPx) / 2;

        // Convert px² to m²
        const mPerPx = 1 / scale / 1000;
        const areaM2 = areaPx * mPerPx * mPerPx;
        
        // Find centroid to place text
        let centroid = { x: 0, y: 0 };
        meteringPoints.forEach(p => {
            centroid.x += p.x;
            centroid.y += p.y;
        });
        centroid.x /= meteringPoints.length;
        centroid.y /= meteringPoints.length;

        const areaText = new fabric.Text(`${areaM2.toFixed(2)} m²`, {
            left: centroid.x,
            top: centroid.y,
            fontSize: 16,
            fill: 'blue',
            fontWeight: 'bold',
            originX: 'center',
            originY: 'center',
            isMeteringObject: true
        });
        meteringObjects.push(areaText);
        canvas2d.add(areaText);
    }

    // --- 3D Scene Management ---
    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 1, 20000);
        camera.position.set(500, 800, 1300);
        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        canvas3d.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(150, 200, 100);
        scene.add(dirLight);
        
        // Create floor
        const floorGeometry = new THREE.PlaneGeometry(10000, 10000);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: document.getElementById('floor-color').value });
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;
        camera.lookAt(controls.target);

        update3DScene(); // Call once on init to set initial textures/colors
    }
    
    function update3DScene() {
        // Update floor material
        if (floor) {
            if (floorTextureURL) {
                // Check if the map needs to be created or updated
                if (!floor.material.map || floor.material.map.image.src !== floorTextureURL) {
                    const texture = new THREE.TextureLoader().load(floorTextureURL);
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(20, 20);
                    floor.material.map = texture;
                    floor.material.color.set(0xffffff); // Use white so texture is not tinted
                    floor.material.needsUpdate = true;
                }
            } else { // If no texture, use color
                if (floor.material.map) { // Remove texture if it exists
                    floor.material.map.dispose();
                    floor.material.map = null;
                }
                floor.material.color.set(document.getElementById('floor-color').value);
                floor.material.needsUpdate = true;
            }
        }

        // Update walls and items
        Object.values(sceneObjects3D).forEach(mesh => {
            scene.remove(mesh);
            mesh.geometry.dispose();
            if(mesh.material.map) mesh.material.map.dispose();
            mesh.material.dispose();
        });
        sceneObjects3D = {};
        const wallHeight = document.getElementById('wall-height').value * scale;
        const defaultWallColor = '#ffffff'; 

        canvas2d.getObjects().forEach(obj2d => {
            if(obj2d.isLengthText || obj2d.isMeteringObject) return;
            if (obj2d.isItem) create3DItem(obj2d);
            else if (obj2d.isWall) create3DWall(obj2d, wallHeight, defaultWallColor);
        });
    }

    function create3DWall(wall2d, wallHeight, defaultColor) {
        const d = fabric.util.qrDecompose(wall2d.calcTransformMatrix());
        const geometry = new THREE.BoxGeometry(wall2d.getScaledWidth(), wallHeight, wall2d.getScaledHeight());
        let material;

        if (wall2d.textureURL) {
            const texture = new THREE.TextureLoader().load(wall2d.textureURL);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            const wallLengthMM = wall2d.getScaledWidth() / scale;
            const wallHeightMM = wallHeight / scale;
            texture.repeat.set(wallLengthMM / 1000, wallHeightMM / 1000); // Repeat every meter
            material = new THREE.MeshStandardMaterial({ map: texture });
        } else {
            const color = wall2d.color3d || defaultColor;
            material = new THREE.MeshStandardMaterial({ color: color });
        }

        const wall3d = new THREE.Mesh(geometry, material);
        wall3d.position.set(d.translateX - canvas2d.width / 2, wallHeight / 2, d.translateY - canvas2d.height / 2);
        wall3d.rotation.y = -fabric.util.degreesToRadians(d.angle);
        sceneObjects3D[wall2d.uid] = wall3d;
        scene.add(wall3d);
    }
    
    function create3DItem(item2d) {
        const props = item2d.itemProps;
        const geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
        let material;

        if (item2d.textureURL) {
            const texture = new THREE.TextureLoader().load(item2d.textureURL);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(props.width / 1000, props.height / 1000); // Repeat every meter on front face
            material = new THREE.MeshStandardMaterial({ map: texture });
        } else {
            const color = props.color || (item2d.fill);
            material = new THREE.MeshStandardMaterial({ color: color });
        }

        const item3d = new THREE.Mesh(geometry, material);
        const center = item2d.getCenterPoint();
        item3d.position.set(
            center.x - canvas2d.width/2, 
            (props.height * scale)/2 + ((props.y || 0) * scale), 
            center.y - canvas2d.height/2
        );
        item3d.rotation.y = -fabric.util.degreesToRadians(item2d.angle);
        sceneObjects3D[item2d.uid] = item3d;
        scene.add(item3d);
    }

    // --- Main Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        if (is3DMode) {
            handle3DCameraMovement();
            controls.update();
            renderer.render(scene, camera);
        } else {
            handle2DPan();
            // renderAll is called by handleMouseMove when drawing, so we avoid redundant calls
            if(!isDrawingWallsMode) {
                canvas2d.renderAll();
            }
        }
    }

    // Initial setup
    updateAllLengthTexts();
    canvas2d.requestRenderAll();
    animate();
</script>

</body>
</html>
