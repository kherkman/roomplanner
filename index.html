<!DOCTYPE html>
<html>
<head>
    <title>2D/3D Room Planner</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            overflow: hidden; /* Prevent scrollbars */
        }
        #menu {
            width: 250px;
            padding: 20px;
            background-color: #f0f0f0;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            height: 100vh;
            z-index: 10;
        }
        #menu h3 { margin-top: 0; }
        #menu .input-group { margin-bottom: 15px; }
        #menu label { display: block; margin-bottom: 5px; }
        #menu input, #menu button {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        #menu button {
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        #menu button:hover { background-color: #0056b3; }
        #menu .control-section button, #menu #metering-button.active, #menu #draw-walls-button.active { background-color: #dc3545; }
        #menu .control-section button:hover, #menu #metering-button.active:hover, #menu #draw-walls-button.active:hover { background-color: #c82333; }
        #menu #load-button, #menu #save-screenshot-button, #menu #apply-texture-button, #menu #apply-floor-texture-button { background-color: #28a745; }
        #menu #load-button:hover, #menu #save-screenshot-button:hover, #menu #apply-texture-button:hover, #menu #apply-floor-texture-button:hover { background-color: #218838; }
        #menu #info-button { background-color: #17a2b8; }
        #menu #info-button:hover { background-color: #138496; }

        #canvas-container {
            flex-grow: 1;
            position: relative;
        }
        #canvas-2d, #canvas-3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Info Modal */
        #info-modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }
        .info-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
        }
        .info-content h2 { margin-top: 0; }
        .info-content ul { list-style-type: none; padding-left: 0;}
        .info-content li { margin-bottom: 10px; }
        .info-content kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-family: monospace;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="menu">
    <h3>File</h3>
    <button id="save-button">Save to File</button>
    <button id="load-button" onclick="document.getElementById('file-input').click()">Load from File</button>
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <button id="save-screenshot-button">Save Screenshot (JPG)</button>
    <hr>
    <h3>Insert</h3>
    <div class="input-group">
        <label for="wall-length">Wall Length (mm):</label>
        <input type="number" id="wall-length" value="4000">
    </div>
    <button id="insert-wall">Insert Wall</button>
    <button id="draw-walls-button">Draw Walls</button>
    <button id="insert-item">Insert Item (Cube)</button>
    <button id="insert-hole">Insert Hole</button>
    <button id="insert-door">Insert Door</button>
    <hr>
    <h3>Controls</h3>
    <button id="metering-button">Start Metering</button>
    <button id="toggle-lengths">Show/Hide Lengths</button>
    <button id="info-button">Show Controls Info</button>

    <div id="selected-object-controls" class="control-section" style="display: none;">
        <hr><h3>Selected Object</h3>
        <button id="remove-object">Remove Selected</button>
        <button id="apply-texture-button" onclick="document.getElementById('texture-file-input').click()">Apply Texture</button>
        <input type="file" id="texture-file-input" style="display: none;" accept=".jpg,.jpeg,.png">
        <!-- Wall-specific controls -->
        <div id="wall-editor-controls" style="display: none;">
            <div class="input-group">
                <label for="edit-wall-length">Length (mm):</label>
                <input type="number" id="edit-wall-length">
            </div>
            <div class="input-group">
                <label for="edit-wall-angle">Angle (°):</label>
                <input type="number" id="edit-wall-angle">
            </div>
        </div>
        <!-- Item-specific controls -->
        <div id="item-editor-controls" style="display: none;">
            <div class="input-group"><label for="item-width">Width (mm):</label><input type="number" id="item-width"></div>
            <div class="input-group"><label for="item-depth">Depth (mm):</label><input type="number" id="item-depth"></div>
            <div class="input-group"><label for="item-height">Height (mm):</label><input type="number" id="item-height"></div>
            <div class="input-group"><label for="item-y-position">Vertical Position (mm):</label><input type="number" id="item-y-position"></div>
        </div>
        <!-- Hole-specific controls -->
        <div id="hole-editor-controls" style="display: none;">
            <div class="input-group"><label for="hole-width">Width (mm):</label><input type="number" id="hole-width"></div>
            <div class="input-group"><label for="hole-height">Height (mm):</label><input type="number" id="hole-height"></div>
            <div class="input-group"><label for="hole-y-position">Vertical Position (mm):</label><input type="number" id="hole-y-position"></div>
        </div>
         <!-- Door-specific controls -->
        <div id="door-editor-controls" style="display: none;">
            <div class="input-group"><label for="door-width">Width (mm):</label><input type="number" id="door-width"></div>
            <div class="input-group"><label for="door-height">Height (mm):</label><input type="number" id="door-height"></div>
            <div class="input-group"><label for="door-color">Color:</label><input type="color" id="door-color"></div>
            <button id="mirror-door-button">Mirror Swing</button>
        </div>
    </div>
    
    <hr>
    <h3>3D View</h3>
    <button id="toggle-3d">Switch to 3D</button>
    <div id="view-controls">
        <div class="input-group">
            <label for="wall-color">Selected Wall 3D Color:</label>
            <input type="color" id="wall-color" value="#ffffff">
        </div>
        <div class="input-group">
            <label for="floor-color">Floor Color:</label>
            <input type="color" id="floor-color" value="#808080">
        </div>
        <button id="apply-floor-texture-button" onclick="document.getElementById('floor-texture-file-input').click()">Apply Floor Texture</button>
        <input type="file" id="floor-texture-file-input" style="display: none;" accept=".jpg,.jpeg,.png">
        <div class="input-group">
            <label for="wall-height">Default Wall Height (mm):</label>
            <input type="number" id="wall-height" value="2400">
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas-2d"></canvas>
    <div id="canvas-3d" style="display: none;"></div>
</div>

<div id="info-modal">
    <div class="info-content">
        <span class="close-button">&times;</span>
        <h2>Controls Guide</h2>
        <h3>2D Mode</h3>
        <ul>
            <li><b>Pan View:</b> <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> keys.</li>
            <li><b>Zoom:</b> Mouse Wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Select/Move/Rotate:</b> Click and drag objects. Use rotation handles.</li>
            <li><b>Multi-Select:</b> Hold <kbd>Shift</kbd> and click multiple objects.</li>
            <li><b>Delete Object:</b> Select an object and press <kbd>Delete</kbd> or <kbd>Backspace</kbd>.</li>
            <li><b>Draw Walls:</b> Activate drawing mode, then click on the canvas to place wall corners. Press <kbd>Esc</kbd> or click the button again to finish.</li>
            <li><b>Metering:</b> Activate metering mode, then click on the canvas to draw a measuring line. Click near the start point to close the loop and calculate area.</li>
        </ul>
        <h3>3D Mode</h3>
        <ul>
            <li><b>Rotate View:</b> Click and drag with the left mouse button.</li>
            <li><b>Pan View:</b> Click and drag with the right mouse button.</li>
            <li><b>Zoom:</b> Use the mouse wheel, or <kbd>R</kbd> / <kbd>F</kbd> keys.</li>
            <li><b>Move Camera (Walk):</b> <kbd>W</kbd> (forward), <kbd>A</kbd> (left), <kbd>S</kbd> (back), <kbd>D</kbd> (right).</li>
            <li><b>Move Camera (Strafe):</b> <kbd>I</kbd> (forward), <kbd>K</kbd> (back), <kbd>J</kbd> (left), <kbd>L</kbd> (right).</li>
            <li><b>Move Camera (Vertical):</b> <kbd>&uarr;</kbd> (up), <kbd>&darr;</kbd> (down).</li>
            <li><b>Open/Close Door:</b> Press <kbd>E</kbd> when near a door.</li>
        </ul>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    const canvasContainer = document.getElementById('canvas-container');
    const scale = 0.1;
    let showLengths = true;
    const keyState = {};
    let uidCounter = 0;

    // --- 2D Canvas ---
    const canvas2d = new fabric.Canvas('canvas-2d', {
        width: canvasContainer.clientWidth,
        height: canvasContainer.clientHeight,
        backgroundColor: 'white',
        preserveObjectStacking: true,
        renderOnAddRemove: false
    });
    const customProps = ['isWall', 'isItem', 'itemProps', 'isHole', 'holeProps', 'isDoor', 'doorProps', 'uid', 'color3d', 'textureURL'];
    let lengthTextObjects = {};

    // --- Mode States ---
    let isMeteringMode = false;
    let meteringPoints = [];
    let meteringObjects = [];
    
    let isDrawingWallsMode = false;
    let wallDrawingPoints = [];
    let previewLine = null;

    // --- 3D Scene ---
    let scene, camera, renderer, controls;
    let floor;
    let sceneObjects3D = {};
    const clock = new THREE.Clock();
    const canvas3d = document.getElementById('canvas-3d');
    let is3DMode = false;
    let floorTextureURL = null;
    
    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
        const activeEl = document.activeElement;
        if(activeEl.tagName !== 'INPUT') {
            keyState[e.key.toLowerCase()] = true;
            handleGlobalKeys(e);
        }
    });
    document.addEventListener('keyup', (e) => keyState[e.key.toLowerCase()] = false);
    
    document.getElementById('save-button').addEventListener('click', saveToFile);
    document.getElementById('file-input').addEventListener('change', loadFromFile);
    document.getElementById('texture-file-input').addEventListener('change', applyTexture);
    document.getElementById('floor-texture-file-input').addEventListener('change', applyFloorTexture);
    document.getElementById('save-screenshot-button').addEventListener('click', saveScreenshot);
    document.getElementById('info-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'block');
    document.querySelector('.close-button').addEventListener('click', () => document.getElementById('info-modal').style.display = 'none');
    window.addEventListener('click', (e) => { if (e.target == document.getElementById('info-modal')) e.target.style.display = 'none'; });
    
    document.getElementById('insert-wall').addEventListener('click', insertWall);
    document.getElementById('draw-walls-button').addEventListener('click', toggleDrawWallsMode);
    document.getElementById('insert-item').addEventListener('click', insertItem);
    document.getElementById('insert-hole').addEventListener('click', insertHole);
    document.getElementById('insert-door').addEventListener('click', insertDoor);
    document.getElementById('mirror-door-button').addEventListener('click', mirrorDoor);
    document.getElementById('remove-object').addEventListener('click', removeSelectedObject);
    document.getElementById('toggle-lengths').addEventListener('click', toggleLengthVisibility);
    document.getElementById('toggle-3d').addEventListener('click', toggle3DMode);
    document.getElementById('metering-button').addEventListener('click', toggleMeteringMode);

    document.getElementById('edit-wall-length').addEventListener('input', updateWallFromMenu);
    document.getElementById('edit-wall-angle').addEventListener('input', updateWallFromMenu);
    document.getElementById('wall-color').addEventListener('input', update3DColorFromMenu);
    
    ['item-width', 'item-depth', 'item-height', 'item-y-position'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateItemFromMenu);
    });
    ['hole-width', 'hole-height', 'hole-y-position'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateHoleFromMenu);
    });
    ['door-width', 'door-height', 'door-color'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateDoorFromMenu);
    });


    window.addEventListener('resize', onWindowResize);
    
    // --- Canvas Event Listeners ---
    function updateTextForObject(obj) {
        if (!showLengths || !obj) return;
        if (obj.isWall) updateLengthTextFor(obj);
    }

    canvas2d.on({
        'mouse:wheel': handle2DZoom,
        'mouse:down': handleMouseDown,
        'mouse:move': handleMouseMove,
        'selection:created': updateMenu,
        'selection:updated': updateMenu,
        'selection:cleared': updateMenu,
        'object:modified': (e) => {
            updateMenu(e);
            if(is3DMode) update3DScene();
        },
        'object:moving': (e) => {
            updateTextForObject(e.target);
            if (is3DMode && (e.target.isHole || e.target.isWall || e.target.isDoor)) {
                 update3DScene();
            }
        },
        'object:rotating': (e) => {
             updateTextForObject(e.target);
             if (is3DMode) update3DScene();
        },
        'object:scaling': (e) => {
            updateTextForObject(e.target)
            if (is3DMode) update3DScene();
        }
    });

    // --- Core Functions ---

    function removeSelectedObject() {
        canvas2d.getActiveObjects().forEach(activeObject => {
            if (lengthTextObjects[activeObject.uid]) {
                canvas2d.remove(lengthTextObjects[activeObject.uid]);
                delete lengthTextObjects[activeObject.uid];
            }
            if (sceneObjects3D[activeObject.uid]) {
                scene.remove(sceneObjects3D[activeObject.uid]);
                delete sceneObjects3D[activeObject.uid];
            }
            canvas2d.remove(activeObject);
        });
        canvas2d.discardActiveObject();
        canvas2d.requestRenderAll();
        if (is3DMode) update3DScene(); 
    }

    function saveToFile() {
        const originalObjects = canvas2d.getObjects().filter(o => !o.isLengthText && !o.isMeteringObject && !o.isWallPoint);
        const json = canvas2d.toObject(customProps);
        json.objects = originalObjects.map(o => o.toObject(customProps));
        json.floorTextureURL = floorTextureURL;
        
        const dataStr = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(json, null, 2))}`;
        const a = document.createElement('a');
        a.href = dataStr;
        a.download = "plan.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    function saveScreenshot() {
        let dataUrl;
        if (is3DMode) {
            renderer.render(scene, camera);
            dataUrl = renderer.domElement.toDataURL('image/jpeg');
        } else {
            dataUrl = canvas2d.toDataURL({
                format: 'jpeg',
                quality: 0.9
            });
        }
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = "screenshot.jpg";
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    function loadFromFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            const data = JSON.parse(f.target.result);
            floorTextureURL = data.floorTextureURL || null;

            canvas2d.loadFromJSON(data, () => {
                const objectsToLoad = [];
                canvas2d.getObjects().forEach(obj => {
                    if(obj.isDoor) {
                        const doorGroup = createDoorGroup(obj.doorProps);
                        doorGroup.set({ left: obj.left, top: obj.top, angle: obj.angle, uid: obj.uid, textureURL: obj.textureURL, scaleY: obj.doorProps.swingDirection || 1 });
                        objectsToLoad.push(doorGroup);
                    } else {
                        if (obj.uid === undefined) obj.uid = ++uidCounter;
                        objectsToLoad.push(obj);
                    }
                });
                
                canvas2d.clear();
                objectsToLoad.forEach(obj => canvas2d.add(obj));

                updateAllLengthTexts();
                canvas2d.requestRenderAll();

                if (is3DMode) {
                    update3DScene();
                }
            });
        };
        reader.readAsText(file);
        e.target.value = '';
    }
    
    function applyTexture(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (f) => {
            const dataURL = f.target.result;
            const activeObjects = canvas2d.getActiveObjects();
            if (activeObjects.length === 0) return;
            activeObjects.forEach(obj => {
                obj.textureURL = dataURL;
                 if (obj.isDoor) {
                    obj.doorProps.textureURL = dataURL;
                }
            });
            if (is3DMode) update3DScene();
        };
        reader.readAsDataURL(file);
        e.target.value = '';
    }
    
    function applyFloorTexture(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            floorTextureURL = f.target.result;
            if (is3DMode && floor) {
                const texture = new THREE.TextureLoader().load(floorTextureURL);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(20, 20);
                floor.material.map = texture;
                floor.material.color.set(0xffffff);
                floor.material.needsUpdate = true;
            }
        };
        reader.readAsDataURL(file);
        e.target.value = '';
    }

    function handleGlobalKeys(e) {
        const key = e.key.toLowerCase();
        if (key === 'escape') {
            if (isDrawingWallsMode) toggleDrawWallsMode();
            if (isMeteringMode) toggleMeteringMode();
        }
        if (key === 'backspace' || key === 'delete') {
            e.preventDefault();
            removeSelectedObject();
        }
        if (key === 'r' || key === 'f') {
            e.preventDefault();
            const zoomFactor = 1.1;
            const zoom = key === 'r' ? zoomFactor : 1 / zoomFactor;
            if (is3DMode) {
                 const forward = new THREE.Vector3();
                 camera.getWorldDirection(forward);
                 camera.position.addScaledVector(forward, (1 - 1/zoom) * 1000);
            } else {
                canvas2d.zoomToPoint(new fabric.Point(canvas2d.width / 2, canvas2d.height / 2), canvas2d.getZoom() * zoom);
            }
        }
        if (key === 'e' && is3DMode) {
            toggleClosestDoor();
        }
    }

    function handle2DZoom(opt) {
        if (isMeteringMode || isDrawingWallsMode) return;
        opt.e.preventDefault();
        opt.e.stopPropagation();
        const delta = opt.e.deltaY;
        let zoom = canvas2d.getZoom();
        zoom *= 0.999 ** delta;
        if (zoom > 20) zoom = 20;
        if (zoom < 0.1) zoom = 0.1;
        canvas2d.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
    }

    function handle2DPan() {
        if(is3DMode) return;
        const panSpeed = 15 / canvas2d.getZoom();
        let panX = 0, panY = 0;
        if (keyState['w']) panY += panSpeed;
        if (keyState['s']) panY -= panSpeed;
        if (keyState['a']) panX += panSpeed;
        if (keyState['d']) panX -= panSpeed;

        if (panX !== 0 || panY !== 0) {
            canvas2d.relativePan(new fabric.Point(panX, panY));
        }
    }
    
    function handle3DCameraMovement() {
        if(!is3DMode) return;
        const moveSpeed = 15.0;
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
        const moveDirection = new THREE.Vector3(0,0,0);
        if (keyState['w'] || keyState['i']) moveDirection.add(forward);
        if (keyState['s'] || keyState['k']) moveDirection.sub(forward);
        if (keyState['a'] || keyState['j']) moveDirection.sub(right);
        if (keyState['d'] || keyState['l']) moveDirection.add(right);
        if(moveDirection.lengthSq() > 0){
            const finalMove = moveDirection.normalize().multiplyScalar(moveSpeed);
            camera.position.add(finalMove);
            controls.target.add(finalMove);
        }
        if (keyState['arrowup']) camera.position.y += moveSpeed;
        if (keyState['arrowdown']) camera.position.y -= moveSpeed;
    }

    function insertWall() {
        const length = document.getElementById('wall-length').value;
        const wall = new fabric.Rect({
            width: length * scale, height: 10, fill: 'black', left: 50, top: 50,
            originX: 'left', originY: 'center', isWall: true, uid: ++uidCounter
        });
        canvas2d.add(wall);
        if (showLengths) updateLengthTextFor(wall);
        canvas2d.requestRenderAll();
    }

    function insertItem() {
        const item = new fabric.Rect({
            width: 600 * scale, height: 600 * scale, fill: '#A52A2A', left: 200, top: 200,
            isItem: true, 
            itemProps: { width: 600, depth: 600, height: 800, y: 0, color: '#A52A2A' }, 
            uid: ++uidCounter
        });
        canvas2d.add(item).requestRenderAll();
    }

    function insertHole() {
        const hole = new fabric.Rect({
            width: 900 * scale, height: 20 * scale,
            fill: 'rgba(0, 100, 255, 0.5)', stroke: 'blue', strokeWidth: 1,
            left: 250, top: 250,
            isHole: true,
            holeProps: { width: 900, height: 1200, y: 800 },
            uid: ++uidCounter
        });
        canvas2d.add(hole).requestRenderAll();
    }

    function createDoorGroup(props) {
        const width_2d = props.width * scale;
        const doorSlabThickness = 40 * scale; 
        
        const slab = new fabric.Rect({
            left: 0,
            top: 0,
            width: width_2d,
            height: doorSlabThickness,
            fill: props.color,
            stroke: 'black',
            strokeWidth: 0.5,
            originX: 'left',
            originY: 'center',
        });
        
        const arc = new fabric.Path(`M 0 0 A ${width_2d} ${width_2d} 0 0 1 ${width_2d} -${width_2d}`, {
            fill: '',
            stroke: 'rgba(0,0,0,0.5)',
            strokeWidth: 1,
            strokeDashArray: [3,3],
            originX: 'left',
            originY: 'top',
        });

        const doorGroup = new fabric.Group([slab, arc], {
            left: 150,
            top: 250,
            isDoor: true,
            doorProps: { ...props },
            uid: ++uidCounter,
            subTargetCheck: true, 
            lockScalingFlip: true,
            originX: 'left',
            originY: 'center'
        });
        return doorGroup;
    }

    function insertDoor() {
        const doorProps = { width: 800, height: 2000, color: '#D2B48C', swingDirection: 1 };
        const door = createDoorGroup(doorProps);
        canvas2d.add(door).requestRenderAll();
    }

    function mirrorDoor() {
        const door = canvas2d.getActiveObject();
        if (!door || !door.isDoor) return;

        door.doorProps.swingDirection *= -1;
        door.scaleY *= -1;
        
        door.setCoords();
        canvas2d.requestRenderAll();
        if(is3DMode) update3DScene();
    }

    function updateMenu(e) {
        document.getElementById('selected-object-controls').style.display = 'none';
        document.getElementById('wall-editor-controls').style.display = 'none';
        document.getElementById('item-editor-controls').style.display = 'none';
        document.getElementById('hole-editor-controls').style.display = 'none';
        document.getElementById('door-editor-controls').style.display = 'none';
        
        const activeObjects = canvas2d.getActiveObjects();
        if (activeObjects.length === 0) return;

        document.getElementById('selected-object-controls').style.display = 'block';

        if (activeObjects.length === 1) {
            const obj = activeObjects[0];
            if (obj.isWall) {
                document.getElementById('wall-editor-controls').style.display = 'block';
                document.getElementById('edit-wall-length').value = Math.round(obj.getScaledWidth() / scale);
                document.getElementById('edit-wall-angle').value = Math.round(obj.angle);
            } else if (obj.isItem) {
                document.getElementById('item-editor-controls').style.display = 'block';
                obj.itemProps.width = obj.getScaledWidth() / scale;
                obj.itemProps.depth = obj.getScaledHeight() / scale;
                document.getElementById('item-width').value = Math.round(obj.itemProps.width);
                document.getElementById('item-depth').value = Math.round(obj.itemProps.depth);
                document.getElementById('item-height').value = obj.itemProps.height;
                document.getElementById('item-y-position').value = obj.itemProps.y || 0;
            } else if (obj.isHole) {
                document.getElementById('hole-editor-controls').style.display = 'block';
                obj.holeProps.width = obj.getScaledWidth() / scale;
                document.getElementById('hole-width').value = Math.round(obj.holeProps.width);
                document.getElementById('hole-height').value = obj.holeProps.height;
                document.getElementById('hole-y-position').value = obj.holeProps.y;
            } else if (obj.isDoor) {
                document.getElementById('door-editor-controls').style.display = 'block';
                document.getElementById('door-width').value = obj.doorProps.width;
                document.getElementById('door-height').value = obj.doorProps.height;
                document.getElementById('door-color').value = obj.doorProps.color;
            }
        }
    }
    
    function updateWallFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isWall) return;
        activeObject.set({
            width: document.getElementById('edit-wall-length').value * scale,
            angle: parseFloat(document.getElementById('edit-wall-angle').value),
            scaleX: 1
        }).setCoords();
        canvas2d.requestRenderAll();
        updateTextForObject(activeObject);
        if(is3DMode) update3DScene();
    }
    
    function update3DColorFromMenu() {
        const color = document.getElementById('wall-color').value;
        canvas2d.getActiveObjects().forEach(obj => {
            if (obj.isWall) obj.color3d = color;
        });
        if (is3DMode) update3DScene();
    }

    function updateItemFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isItem) return;
        const props = activeObject.itemProps;
        props.width = document.getElementById('item-width').value;
        props.depth = document.getElementById('item-depth').value;
        props.height = document.getElementById('item-height').value;
        props.y = parseFloat(document.getElementById('item-y-position').value) || 0;
        activeObject.set({
            width: props.width * scale,
            height: props.depth * scale,
            scaleX: 1, scaleY: 1
        }).setCoords();
        canvas2d.requestRenderAll();
        if (is3DMode) update3DScene();
    }

    function updateHoleFromMenu() {
        const activeObject = canvas2d.getActiveObject();
        if (!activeObject || !activeObject.isHole) return;
        const props = activeObject.holeProps;
        props.width = parseFloat(document.getElementById('hole-width').value);
        props.height = parseFloat(document.getElementById('hole-height').value);
        props.y = parseFloat(document.getElementById('hole-y-position').value);
        activeObject.set({ width: props.width * scale, scaleX: 1 }).setCoords();
        canvas2d.requestRenderAll();
        if (is3DMode) update3DScene();
    }

    function updateDoorFromMenu() {
        const oldGroup = canvas2d.getActiveObject();
        if (!oldGroup || !oldGroup.isDoor) return;

        const newProps = {
            width: parseFloat(document.getElementById('door-width').value),
            height: parseFloat(document.getElementById('door-height').value),
            color: document.getElementById('door-color').value,
            swingDirection: oldGroup.doorProps.swingDirection
        };

        const preservedProps = {
            left: oldGroup.left, top: oldGroup.top, angle: oldGroup.angle,
            uid: oldGroup.uid, textureURL: oldGroup.textureURL, scaleY: oldGroup.scaleY
        };

        canvas2d.remove(oldGroup);
        const newGroup = createDoorGroup(newProps);
        newGroup.set(preservedProps);
        newGroup.doorProps.textureURL = preservedProps.textureURL;

        canvas2d.add(newGroup);
        canvas2d.setActiveObject(newGroup);
        canvas2d.requestRenderAll();
        if (is3DMode) update3DScene();
    }
    
    function toggleLengthVisibility() {
        showLengths = !showLengths;
        Object.values(lengthTextObjects).forEach(text => text.visible = showLengths);
        if (showLengths) updateAllLengthTexts();
        canvas2d.requestRenderAll();
    }

    function updateAllLengthTexts() {
        const visibleObjects = new Set();
        canvas2d.getObjects().forEach(obj => {
            if (obj.isWall) {
                updateLengthTextFor(obj);
                visibleObjects.add(obj.uid);
            }
        });
        for (const uid in lengthTextObjects) {
            if (!visibleObjects.has(parseInt(uid))) lengthTextObjects[uid].visible = false;
        }
    }

    function updateLengthTextFor(wall) {
        let textObj = lengthTextObjects[wall.uid];
        if (!textObj) {
            textObj = new fabric.Text('', { fontSize: 12, fill: 'black', originX: 'center', originY: 'center', selectable: false, evented: false });
            lengthTextObjects[wall.uid] = textObj;
            canvas2d.add(textObj);
        }
        textObj.visible = true;
        textObj.text = `${Math.round(wall.getScaledWidth() / scale)} mm`;
        const d = fabric.util.qrDecompose(wall.calcTransformMatrix());
        const center = new fabric.Point(d.translateX, d.translateY);
        const offset = new fabric.Point(0, -20);
        const rotatedOffset = fabric.util.rotatePoint(offset, new fabric.Point(0,0), fabric.util.degreesToRadians(d.angle));
        textObj.set({ left: center.x + rotatedOffset.x, top: center.y + rotatedOffset.y, angle: d.angle });
        textObj.bringToFront();
    }

    function onWindowResize() {
        const w = canvasContainer.clientWidth, h = canvasContainer.clientHeight;
        canvas2d.setDimensions({ width: w, height: h });
        if (is3DMode) {
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }
    }

    function toggle3DMode() {
        is3DMode = !is3DMode;
        if (is3DMode) {
            document.getElementById('toggle-3d').textContent = 'Switch to 2D';
            canvas2d.getElement().style.display = 'none';
            canvas3d.style.display = 'block';
            if (!renderer) init3D();
            onWindowResize();
            update3DScene();
        } else {
            document.getElementById('toggle-3d').textContent = 'Switch to 3D';
            canvas2d.getElement().style.display = 'block';
            canvas3d.style.display = 'none';
        }
    }
    
    function setCanvasInteraction(enabled) {
        canvas2d.selection = enabled;
        canvas2d.forEachObject(o => o.set('evented', enabled));
    }
    
    function toggleDrawWallsMode() {
        const btn = document.getElementById('draw-walls-button');
        isDrawingWallsMode = !isDrawingWallsMode;
        if (isDrawingWallsMode) {
            if(isMeteringMode) toggleMeteringMode();
            btn.textContent = 'Finish Drawing';
            btn.classList.add('active');
            setCanvasInteraction(false);
        } else {
            btn.textContent = 'Draw Walls';
            btn.classList.remove('active');
            setCanvasInteraction(true);
            wallDrawingPoints = [];
            if(previewLine) canvas2d.remove(previewLine);
            previewLine = null;
            canvas2d.requestRenderAll();
        }
    }

    function createWallSegment(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = fabric.util.radiansToDegrees(Math.atan2(dy, dx));
        const wall = new fabric.Rect({
            left: p1.x, top: p1.y, width: length, height: 10, angle: angle,
            fill: 'black', originX: 'left', originY: 'center', isWall: true, uid: ++uidCounter
        });
        canvas2d.add(wall);
        updateLengthTextFor(wall);
    }
    
    function toggleMeteringMode() {
        const btn = document.getElementById('metering-button');
        isMeteringMode = !isMeteringMode;
        if (isMeteringMode) {
            if(isDrawingWallsMode) toggleDrawWallsMode();
            btn.textContent = 'Cancel Metering';
            btn.classList.add('active');
            clearMetering();
            setCanvasInteraction(false);
        } else {
            btn.textContent = 'Start Metering';
            btn.classList.remove('active');
            clearMetering();
            setCanvasInteraction(true);
        }
    }

    function clearMetering() {
        canvas2d.remove(...meteringObjects);
        meteringObjects = [];
        meteringPoints = [];
        canvas2d.requestRenderAll();
    }

    function handleMouseMove(opt) {
        if (!isDrawingWallsMode || wallDrawingPoints.length === 0) return;
        if (previewLine) canvas2d.remove(previewLine);
        const pointer = canvas2d.getPointer(opt.e);
        const startPoint = wallDrawingPoints[wallDrawingPoints.length - 1];
        previewLine = new fabric.Line([startPoint.x, startPoint.y, pointer.x, pointer.y], {
            stroke: 'rgba(0,0,0,0.3)', strokeWidth: 2, selectable: false, evented: false, strokeDashArray: [5, 5]
        });
        canvas2d.add(previewLine).requestRenderAll();
    }

    function handleMouseDown(opt) {
        if(isDrawingWallsMode) {
            const pointer = canvas2d.getPointer(opt.e);
            wallDrawingPoints.push(pointer);
            if (wallDrawingPoints.length > 1) {
                createWallSegment(wallDrawingPoints[wallDrawingPoints.length - 2], pointer);
            }
            return;
        }
        if (!isMeteringMode) return;
        const pointer = canvas2d.getPointer(opt.e);
        if (meteringPoints.length > 2) {
            const startPoint = meteringPoints[0];
            const dist = Math.hypot(startPoint.x - pointer.x, startPoint.y - pointer.y);
            if (dist < 10) {
                drawMeteringLine(meteringPoints[meteringPoints.length - 1], startPoint);
                calculateAndShowArea();
                isMeteringMode = false;
                return;
            }
        }
        meteringPoints.push(pointer);
        const circle = new fabric.Circle({
            radius: 3, fill: 'red', left: pointer.x, top: pointer.y,
            originX: 'center', originY: 'center', isMeteringObject: true
        });
        meteringObjects.push(circle);
        canvas2d.add(circle);
        if (meteringPoints.length > 1) {
            drawMeteringLine(meteringPoints[meteringPoints.length - 2], pointer);
        }
    }

    function drawMeteringLine(p1, p2) {
        const line = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
            stroke: 'red', strokeWidth: 2, selectable: false, evented: false, isMeteringObject: true
        });
        meteringObjects.push(line);
        canvas2d.add(line);
        const lengthMM = Math.hypot(p1.x - p2.x, p1.y - p2.y) / scale;
        const text = new fabric.Text(`${Math.round(lengthMM)} mm`, {
            left: (p1.x + p2.x) / 2, top: (p1.y + p2.y) / 2, fontSize: 14,
            fill: 'black', originX: 'center', originY: 'center', isMeteringObject: true
        });
        meteringObjects.push(text);
        canvas2d.add(text);
    }
    
    function calculateAndShowArea() {
        let areaPx = 0;
        for (let i = 0; i < meteringPoints.length; i++) {
            const p1 = meteringPoints[i];
            const p2 = meteringPoints[(i + 1) % meteringPoints.length];
            areaPx += (p1.x * p2.y - p2.x * p1.y);
        }
        areaPx = Math.abs(areaPx) / 2;
        const areaM2 = areaPx * (1 / scale / 1000)**2;
        let centroid = meteringPoints.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0, y:0});
        centroid.x /= meteringPoints.length;
        centroid.y /= meteringPoints.length;
        const areaText = new fabric.Text(`${areaM2.toFixed(2)} m²`, {
            left: centroid.x, top: centroid.y, fontSize: 16, fill: 'blue', fontWeight: 'bold',
            originX: 'center', originY: 'center', isMeteringObject: true
        });
        meteringObjects.push(areaText);
        canvas2d.add(areaText);
    }

    // --- 3D Scene Management ---
    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 1, 20000);
        camera.position.set(500, 800, 1300);
        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        canvas3d.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(150, 200, 100);
        scene.add(dirLight);
        
        const floorGeometry = new THREE.PlaneGeometry(10000, 10000);
        const materialConfig = {};
        if (floorTextureURL) {
            const texture = new THREE.TextureLoader().load(floorTextureURL);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20);
            materialConfig.map = texture;
            materialConfig.color = 0xffffff;
        } else {
            materialConfig.color = document.getElementById('floor-color').value;
        }
        const floorMaterial = new THREE.MeshStandardMaterial(materialConfig);
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableKeys = false;
        camera.lookAt(controls.target);
    }
    
    function update3DScene() {
        if (floor) {
            if (floorTextureURL) {
                if (!floor.material.map || floor.material.map.image.src !== floorTextureURL) {
                    const texture = new THREE.TextureLoader().load(floorTextureURL);
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(20, 20);
                    floor.material.map = texture;
                    floor.material.color.set(0xffffff);
                    floor.material.needsUpdate = true;
                }
            } else {
                floor.material.map = null;
                floor.material.color.set(document.getElementById('floor-color').value);
                floor.material.needsUpdate = true;
            }
        }

        Object.values(sceneObjects3D).forEach(obj => scene.remove(obj));
        sceneObjects3D = {};

        const allObjects = canvas2d.getObjects();
        const walls = allObjects.filter(o => o.isWall);
        const items = allObjects.filter(o => o.isItem);
        const holes = allObjects.filter(o => o.isHole);
        const doors = allObjects.filter(o => o.isDoor);
        const wallHeight = document.getElementById('wall-height').value;
        const defaultWallColor = '#ffffff'; 

        items.forEach(item2d => create3DItem(item2d));
        doors.forEach(door2d => {
            const wall = walls.find(w => w.intersectsWithObject(door2d));
            create3DDoor(door2d, wall);
        });
        const openings = [...holes, ...doors];
        walls.forEach(wall2d => create3DWall(wall2d, wallHeight, defaultWallColor, openings));
    }

    function create3DWall(wall2d, wallHeight_mm, defaultColor, allOpenings) {
        wall2d.setCoords();

        const wallLength_scene = wall2d.getScaledWidth();
        const wallHeight_scene = wallHeight_mm * scale;
        const wallThickness_scene = wall2d.getScaledHeight();

        const intersectingOpenings = allOpenings.filter(op => op.intersectsWithObject(wall2d));

        const wallShape = new THREE.Shape();
        wallShape.moveTo(0, 0);
        wallShape.lineTo(wallLength_scene, 0);
        wallShape.lineTo(wallLength_scene, wallHeight_scene);
        wallShape.lineTo(0, wallHeight_scene);
        wallShape.lineTo(0, 0);

        const wallAngle_rad = fabric.util.degreesToRadians(wall2d.angle);
        const wallTopLeft_canvas = wall2d.getPointByOrigin('left', 'top');

        intersectingOpenings.forEach(opening2d => {
            let props, width_mm, height_mm, y_mm;
            if (opening2d.isHole) {
                props = opening2d.holeProps;
                width_mm = props.width; height_mm = props.height; y_mm = props.y;
            } else if (opening2d.isDoor) {
                props = opening2d.doorProps;
                width_mm = props.width; height_mm = props.height; y_mm = 0;
            }

            const openingWidth_scene = width_mm * scale;
            const openingHeight_scene = height_mm * scale;
            const openingY_scene = y_mm * scale;
            
            const openingRefPoint_canvas = opening2d.isDoor ? new fabric.Point(opening2d.left, opening2d.top) : opening2d.getCenterPoint();
            const vectorFromWallOrigin = openingRefPoint_canvas.subtract(wallTopLeft_canvas);
            const rotatedVector = fabric.util.rotatePoint(vectorFromWallOrigin, new fabric.Point(0,0), -wallAngle_rad);

            const openingStartX_scene = opening2d.isDoor ? rotatedVector.x : rotatedVector.x - (openingWidth_scene / 2);
            
            const holePath = new THREE.Path();
            holePath.moveTo(openingStartX_scene, openingY_scene);
            holePath.lineTo(openingStartX_scene + openingWidth_scene, openingY_scene);
            holePath.lineTo(openingStartX_scene + openingWidth_scene, openingY_scene + openingHeight_scene);
            holePath.lineTo(openingStartX_scene, openingY_scene + openingHeight_scene);
            holePath.lineTo(openingStartX_scene, openingY_scene);
            wallShape.holes.push(holePath);
        });

        const extrudeSettings = { steps: 1, depth: wallThickness_scene, bevelEnabled: false };
        const geometry = new THREE.ExtrudeGeometry(wallShape, extrudeSettings);

        let material;
        if (wall2d.textureURL) {
            const texture = new THREE.TextureLoader().load(wall2d.textureURL);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set( (wall2d.getScaledWidth() / scale) / 1000, wallHeight_mm / 1000);
            material = new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide });
        } else {
            const color = wall2d.color3d || defaultColor;
            material = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide });
        }

        const wall3d = new THREE.Mesh(geometry, material);
        wall3d.position.set(wallTopLeft_canvas.x - canvas2d.width / 2, 0, wallTopLeft_canvas.y - canvas2d.height / 2);
        wall3d.rotation.y = -wallAngle_rad;
        
        sceneObjects3D[wall2d.uid] = wall3d;
        scene.add(wall3d);
    }
    
    function create3DItem(item2d) {
        const props = item2d.itemProps;
        const geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, props.depth * scale);
        let material;
        if (item2d.textureURL) {
            const texture = new THREE.TextureLoader().load(item2d.textureURL);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(props.width / 1000, props.height / 1000);
            material = new THREE.MeshStandardMaterial({ map: texture });
        } else {
            const color = props.color || (item2d.fill);
            material = new THREE.MeshStandardMaterial({ color: color });
        }
        const item3d = new THREE.Mesh(geometry, material);
        const center = item2d.getCenterPoint();
        item3d.position.set(
            center.x - canvas2d.width/2, 
            (props.height * scale)/2 + ((props.y || 0) * scale), 
            center.y - canvas2d.height/2
        );
        item3d.rotation.y = -fabric.util.degreesToRadians(item2d.angle);
        sceneObjects3D[item2d.uid] = item3d;
        scene.add(item3d);
    }

    function create3DDoor(door2d, wall2d) {
        const props = door2d.doorProps;
        const doorThickness_mm = 40; 
        const geometry = new THREE.BoxGeometry(props.width * scale, props.height * scale, doorThickness_mm * scale);
        
        // Translate geometry to set the pivot point to the left edge.
        geometry.translate((props.width * scale) / 2, 0, 0);

        let material;
        if (door2d.textureURL) {
            const texture = new THREE.TextureLoader().load(door2d.textureURL);
            material = new THREE.MeshStandardMaterial({ map: texture });
        } else {
            material = new THREE.MeshStandardMaterial({ color: props.color });
        }
        const door3d = new THREE.Mesh(geometry, material);
        const doorAngle_rad = -fabric.util.degreesToRadians(door2d.angle);
        
        const hingePoint = new fabric.Point(door2d.left, door2d.top);
        
        door3d.position.set(
            hingePoint.x - canvas2d.width / 2,
            (props.height * scale) / 2,
            hingePoint.y - canvas2d.height / 2
        );
        door3d.rotation.y = doorAngle_rad;
        
        const wallThickness_scene = wall2d ? wall2d.getScaledHeight() : 100 * scale;
        
        // Offset the door from the wall's centerline to its face, respecting the swing direction
        const offset = new THREE.Vector3(0, 0, (wallThickness_scene / 2) * props.swingDirection);
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), doorAngle_rad);
        door3d.position.add(offset);
        
        door3d.userData.isDoor = true;
        door3d.userData.isOpen = false;
        door3d.userData.isAnimating = false;
        door3d.userData.swingDirection = props.swingDirection;
        door3d.userData.originalRotationY = door3d.rotation.y;
        
        sceneObjects3D[door2d.uid] = door3d;
        scene.add(door3d);
    }

    function toggleClosestDoor() {
        let closestDoor = null;
        let minDistance = 2000;

        const cameraPosition = camera.position;
        
        scene.children.forEach(child => {
            if (child.userData.isDoor) {
                const distance = child.position.distanceTo(cameraPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestDoor = child;
                }
            }
        });

        if (closestDoor && !closestDoor.userData.isAnimating) {
            closestDoor.userData.isAnimating = true;
            closestDoor.userData.isOpen = !closestDoor.userData.isOpen;
            closestDoor.userData.animationProgress = 0;
            closestDoor.userData.startRotationY = closestDoor.rotation.y;

            const openAngle = closestDoor.userData.originalRotationY + ((Math.PI / 2) * closestDoor.userData.swingDirection);
            closestDoor.userData.targetRotationY = closestDoor.userData.isOpen ? openAngle : closestDoor.userData.originalRotationY;
        }
    }

    // --- Main Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        if (is3DMode) {
            handle3DCameraMovement();
            controls.update();

            scene.children.forEach(child => {
                if (child.userData.isAnimating) {
                    child.userData.animationProgress += delta * 2;
                    child.rotation.y = THREE.MathUtils.lerp(child.userData.startRotationY, child.userData.targetRotationY, child.userData.animationProgress);

                    if (child.userData.animationProgress >= 1) {
                        child.rotation.y = child.userData.targetRotationY;
                        child.userData.isAnimating = false;
                        child.userData.animationProgress = 0;
                    }
                }
            });

            renderer.render(scene, camera);
        } else {
            handle2DPan();
            if(!isDrawingWallsMode) canvas2d.renderAll();
        }
    }

    // Initial setup
    animate();

</script>

</body>
</html>
